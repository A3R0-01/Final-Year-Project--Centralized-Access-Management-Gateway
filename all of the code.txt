
"""
Django settings for core_access_management_v2 project.

Generated by 'django-admin startproject' using Django 5.1.5.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
from celery.schedules import crontab
import json
from datetime import time

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-7z4m=ov8b*dz7m9zb^oj5wbn58=8@4qxsc0xy9o%u_s1*x)c6@'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ["host.docker.internal", '127.0.0.1', 'localhost']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework_simplejwt',
    'corsheaders',
    'rest_framework',
    'django_prometheus',
    'django_celery_results',
    # 'django_crontab',
    'core',
    'core.citizen',
    'core.auth',
    'core.siteManager',
    'core.administrator',
    'core.grantee',
    'core.department',
    'core.association',
    'core.publicService',
    'core.request',
    'core.grant',
    'core.servicePermissions',
    'core.systemLog',
    'core.systemCron',
    'core.serviceSession'
]
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework_simplejwt.authentication.JWTAuthentication',),
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.DjangoFilterBackend'],
}

MIDDLEWARE = [
    'django_prometheus.middleware.PrometheusBeforeMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'django_prometheus.middleware.PrometheusAfterMiddleware',
]

ROOT_URLCONF = 'core_access_management_v2.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'core_access_management_v2.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django_prometheus.db.backends.postgresql',
        'NAME': 'core_access_management_v2',
        'PASSWORD': 'bsrvnt',
        'USER': 'postgres',
        'HOST': 'localhost',
    }
}

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]
AUTH_USER_MODEL = 'citizen.Citizen'


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# System Crons
# CRONJOBS = [
#     ('*/2 * * * *', 'django.core.management.call_command', ['systemlogcron']),
# ]
CELERY_RESULT_BACKEND = 'django-db'
CELERY_TASK_DEFAULT_QUEUE = 'celery'
CELERY_BEAT_SCHEDULE = {
    'system_log_cron': {
        'task': 'myapp.tasks.system_log_cron',
        'schedule': crontab(minute='*/2'),
    },
}
# Topic for the Kafka system logs

SYSTEM_LOG_KAFKA_SETTINGS = {
    "topic" : "systemLog",
    "group_id": "systemLog",
    "auto_offset_reset": 'earliest',
    'value_deserializer': lambda v : json.loads(v.decode('utf-8')),
    "enable_auto_commit": True
}
CORS_ALLOW_ALL_ORIGINS = True
DEFAULT_SESSION_TIME = 2 
# CORS_ALLOWED_ORIGINS = [
#     "http://localhost:3001",  # React/Next.js frontend
#     "http://127.0.0.1:3001",
# ]

"""
URL configuration for core_access_management_v2 project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from core.routers import urlPatterns
from django_prometheus import urls

from django_prometheus import exports

promPatterns = [path("promMetrics", exports.ExportToDjangoView, name="prometheus-django-metrics")]

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(urlPatterns)),
    path('', include(promPatterns)),
]

from rest_framework import routers
from core.citizen.viewsets import CitizenViewSet, SiteManagerCitizenModelViewSet, AdministratorCitizenModelViewSet, GranteeCitizenModelViewSet
from core.siteManager.viewsets import SiteManagerModelViewSet
from core.administrator.viewsets import SiteManagerAdministratorModelViewSet, AdministratorModelViewSet
from core.grantee.viewset import AdministratorGranteeViewSet, GranteeModelsViewSet, SiteManagerGranteeViewSet
from core.auth.viewsets import RegisterViewSet, LoginCitizenViewSet, RefreshViewSet, LoginSiteManagerViewSet, LoginAdministratorViewSet, LoginGranteeViewSet
from core.department.viewsets import CitizenDepartmentViewSet, GranteeDepartmentViewSet, AdministratorDepartmentViewSet, SiteManagerDepartmentViewSet
from core.association.viewsets import CitizenAssociationModelViewSet, GranteeAssociationModelViewSet, AdministratorAssociationModelViewSet, SiteManagerAssociationModelViewSet
from core.publicService.viewset import CitizenPublicServiceViewSet, GranteePublicServiceViewSet, AdministratorPublicServiceViewSet, SiteManagerPublicServiceViewSet
from core.request.viewsets import CitizenRequestViewSet, GranteeRequestViewSet, AdministratorRequestViewSet, SiteManagerRequestViewSet
from core.grant.viewsets import CitizenGrantViewSet, GranteeGrantViewSet, AdministratorGrantViewSet, SiteManagerGrantViewSet
from core.systemLog.viewsets import GranteeCitizenLogViewSet, AdministratorCitizenLogViewSet, AdministratorGranteeLogViewSet, SiteManagerCitizenLogViewSet, SiteManagerGranteeLogViewSet, SiteManagerAdministratorLogViewSet, SiteManagerManagerLogViewSet
from core.serviceSession.viewset import SiteManagerServiceSessionViewSet, AdministratorServiceSessionViewSet, GranteeServiceSessionViewSet
from core.servicePermissions.viewsets import (
    SiteManagerAssociationPermissionViewSet, SiteManagerPublicServicePermissionViewSet, SiteManagerDepartmentPermissionViewSet,
    AdministratorAssociationPermissionViewSet, AdministratorPublicServicePermissionViewSet, AdministratorDepartmentPermissionViewSet,
    GranteePublicServicePermissionViewSet
)

router  = routers.SimpleRouter()



#Citizen
router.register(r'citizen', CitizenViewSet, basename='citizen')
router.register(r'auth/register', RegisterViewSet, basename='auth-register')
router.register(r'auth/login', LoginCitizenViewSet, basename='auth-login-citizen')
router.register(r'auth/refresh', RefreshViewSet, basename='auth-refresh-citizen')
router.register(r'department', CitizenDepartmentViewSet, basename='department')
router.register(r'association', CitizenAssociationModelViewSet, basename='association')
router.register(r'service', CitizenPublicServiceViewSet, basename='service')
router.register(r'request', CitizenRequestViewSet, basename='request')
router.register(r'grant', CitizenGrantViewSet, basename='grant')



# SiteManager
router.register(r'manager/manager', SiteManagerModelViewSet, basename='Manager')
router.register(r'manager/login', LoginSiteManagerViewSet, basename='auth-login-manager')
router.register(r'manager/citizen', SiteManagerCitizenModelViewSet, basename='manager-citizen')
router.register(r'manager/administrator', SiteManagerAdministratorModelViewSet, basename='manager-administrator')
router.register(r'manager/grantee', SiteManagerGranteeViewSet, basename='manager-grantee')
router.register(r'manager/department', SiteManagerDepartmentViewSet, basename='manager-department')
router.register(r'manager/association', SiteManagerAssociationModelViewSet, basename='manager-association')
router.register(r'manager/service', SiteManagerPublicServiceViewSet, basename='manager-service')
router.register(r'manager/request', SiteManagerRequestViewSet, basename='manager-request')
router.register(r'manager/grant', SiteManagerGrantViewSet, basename='manager-grant')
router.register(r'manager/log/citizen', SiteManagerCitizenLogViewSet, basename='manager-log-citizen')
router.register(r'manager/log/grantee', SiteManagerGranteeLogViewSet, basename='manager-log-grantee')
router.register(r'manager/log/administrator', SiteManagerAdministratorLogViewSet, basename='manager-log-administrator')
router.register(r'manager/log/manager', SiteManagerManagerLogViewSet, basename='manager-log-manager')
router.register(r'manager/permission/department', SiteManagerDepartmentPermissionViewSet, basename='manager-permission-department')
router.register(r'manager/permission/association', SiteManagerAssociationPermissionViewSet, basename='manager-permission-association')
router.register(r'manager/permission/service', SiteManagerPublicServicePermissionViewSet, basename='manager-permission-service')
router.register(r'manager/session', SiteManagerServiceSessionViewSet, basename='manager-session')


# Administrator
router.register(r'admin/login', LoginAdministratorViewSet, basename='auth-login-admin')
router.register(r'admin/citizen', AdministratorCitizenModelViewSet, basename='admin-citizen')
router.register(r'admin/admin', AdministratorModelViewSet, basename='admin-administrator')
router.register(r'admin/grantee', AdministratorGranteeViewSet, basename='admin-grantee')
router.register(r'admin/department', AdministratorDepartmentViewSet, basename='admin-department')
router.register(r'admin/association', AdministratorAssociationModelViewSet, basename='admin-association')
router.register(r'admin/service', AdministratorPublicServiceViewSet, basename='admin-service')
router.register(r'admin/request', AdministratorRequestViewSet, basename='admin-request')
router.register(r'admin/grant', AdministratorGrantViewSet, basename='admin-grant')
router.register(r'admin/log/citizen', AdministratorCitizenLogViewSet, basename='admin-log-citizen')
router.register(r'admin/log/grantee', AdministratorGranteeLogViewSet, basename='admin-log-grantee')
router.register(r'admin/permission/department', AdministratorDepartmentPermissionViewSet, basename='admin-permission-department')
router.register(r'admin/permission/association', AdministratorAssociationPermissionViewSet, basename='admin-permission-association')
router.register(r'admin/permission/service', AdministratorPublicServicePermissionViewSet, basename='admin-permission-service')
router.register(r'admin/session', AdministratorServiceSessionViewSet, basename='admin-session')



# Grantee
router.register(r'grantee/login', LoginGranteeViewSet, basename='auth-login-grantee')
router.register(r'grantee/grantee', GranteeModelsViewSet, basename='grantee-grantee')
router.register(r'grantee/citizen', GranteeCitizenModelViewSet, basename='grantee-citizen')
router.register(r'grantee/department', GranteeDepartmentViewSet, basename='grantee-department')
router.register(r'grantee/association', GranteeAssociationModelViewSet, basename='grantee-association')
router.register(r'grantee/service', GranteePublicServiceViewSet, basename='grantee-service')
router.register(r'grantee/permission/service', GranteePublicServicePermissionViewSet, basename='grantee-permission-service')
router.register(r'grantee/request', GranteeRequestViewSet, basename='grantee-request')
router.register(r'grantee/grant', GranteeGrantViewSet, basename='grantee-grant')
router.register(r'grantee/session', GranteeServiceSessionViewSet, basename='grantee-session')
# router.register(r'grantee/log', GranteeCitizenLogViewSet, basename='grantee-log')



urlPatterns = [
    *router.urls,
]

from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework_simplejwt.settings import api_settings
from rest_framework.exceptions import NotFound, PermissionDenied, AuthenticationFailed
from django.core.exceptions import ObjectDoesNotExist
from core.siteManager.models import SiteManager

class IsSiteManager(JWTAuthentication):
    def authenticate(self, request):
        # ManagerPassword, ManagerUserName = request.data['ManagerPassword'], request.data['ManagerUserName']
        data = super().authenticate(request)
        if data == None:
            raise AuthenticationFailed('Invalid Credentials. Please Login')
        authenticatedUser, token = data
        if hasattr(authenticatedUser, 'sitemanager'):
            # siteManager: SiteManager = authenticatedUser.siteManager
            # if siteManager.ManagerUserName == ManagerUserName and siteManager.check_password(ManagerPassword):
            return authenticatedUser, token
        AuthenticationFailed('Invalid Credentials. Please Login')

class IsAdministrator(JWTAuthentication):
    def authenticate(self, request):
        data = super().authenticate(request)
        if data == None:
            raise AuthenticationFailed('Invalid Credentials. Please Login')
        authenticatedUser, token = data
        if hasattr(authenticatedUser, 'administrator'):
            return authenticatedUser, token
        raise AuthenticationFailed('Invalid Credentials. Please Login')

class IsGrantee(JWTAuthentication):

    def authenticate(self, request):
        data = super().authenticate(request)
        if data == None:
            raise AuthenticationFailed('Invalid Credentials. Please Login')
        authenticatedUser, token = data
        if hasattr(authenticatedUser, 'grantee'):
            return authenticatedUser, token
        raise AuthenticationFailed('Invalid Credentials. Please Login')
from django.db import models
from django.core.exceptions import ObjectDoesNotExist
from rest_framework.exceptions import NotFound
import uuid

# Create your models here.
class AbstractManager(models.Manager):

    def get_by_id(self, id: str) -> models.Model:
        try:
            instance = self.get(PublicId=id)
            return instance
        except (ObjectDoesNotExist, ValueError, TypeError):
            raise NotFound()

class AbstractModel(models.Model):
    PublicId = models.UUIDField(unique=True, db_index=True, default=uuid.uuid4, editable=False)
    Created = models.DateTimeField(auto_now_add=True)
    Updated = models.DateTimeField(auto_now=True)

    objects:AbstractManager = AbstractManager()

    def get_model_fields(self) -> list[str]:
        fields = self._meta.get_fields()
        attributes = [field.name for field in fields if field.concrete]
        return attributes
    class Meta:
        abstract = True


from rest_framework import serializers
from .models import AbstractModel

class AbstractModelSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(format='hex', source='PublicId', read_only=True)
    Created = serializers.DateTimeField(read_only=True)
    Updated = serializers.DateTimeField(read_only=True)

    class Meta:
        model:AbstractModel = AbstractModel
        read_only_fields = ['id', 'created', 'updated']

from django.shortcuts import render
from rest_framework.viewsets import ModelViewSet
from rest_framework.permissions import AllowAny, IsAuthenticatedOrReadOnly, IsAuthenticated
from rest_framework.status import HTTP_201_CREATED
from rest_framework.response import Response
from rest_framework.exceptions import NotFound, ValidationError
from django.core.exceptions import ObjectDoesNotExist, ValidationError
from .serializers import AbstractModelSerializer
from .models import AbstractManager
from .authenticationClasses import IsSiteManager, IsAdministrator, IsGrantee
from pprint import pprint
# Create your views here.

class AbstractModelViewSet(ModelViewSet):
    permission_classes = (IsAuthenticatedOrReadOnly,)
    http_method_names = ['get', 'post', 'patch']
    serializer_class : AbstractModelSerializer = AbstractModelSerializer

    def get_object(self):
        id = self.kwargs['pk']
        try:
            obj = self.get_queryset().get(PublicId=id)
        except (ObjectDoesNotExist, ValidationError, ValueError, TypeError):
            raise NotFound("Record Not Found")
        self.check_object_permissions(self.request, obj)
        return obj

    def get_query_keys(self) -> list[str]:
        query_params = self.request.GET
        query_list = list(query_params.keys())
        return query_list

    def get_model_attributes(self):
        model_fields = self.serializer_class.Meta.model._meta.get_fields()
        attribute_list = [field.name for field in model_fields if field.concrete]
        return attribute_list

    def get_queries(self) -> dict:
        model_attributes = self.get_model_attributes()
        key_words = {}
        for query in self.get_query_keys() :
            for attribute in model_attributes:
                if attribute in query: 
                    value = self.request.query_params.get(query)
                    if "__in" in query:
                        value = self.parse_unquoted_list(value)
                    key_words[query] = value
        return key_words
    
    def parse_unquoted_list(self, s:str):
        # Remove square brackets and strip whitespace
        s = s.strip("[]").strip()

        # Split on comma and strip each part
        elements = [item.strip() for item in s.split(",") if item.strip()]

        return elements
    def get_queryset(self):
        queries = self.get_queries()
        return self.serializer_class.Meta.model.objects.filter(**queries)

    def secondary_create(self, serializer_class: AbstractModelSerializer, data : dict[str], *args, **kwargs) -> str:
        serializer : AbstractModelSerializer = serializer_class(data=data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        return serializer.data['id']

    def create(self, request, *args, **kwargs):
        serializer : AbstractModelSerializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer=serializer)
        return Response(serializer.data, HTTP_201_CREATED)
    

class AbstractGranteeModelViewSet(AbstractModelViewSet):
    http_method_names = ('patch', 'get', 'post')
    permission_classes = (IsAuthenticated,)
    def get_authenticators(self):
        customAuthenticators = [IsGrantee()]
        return customAuthenticators

    def get_object(self):

        id = self.kwargs['pk']
        try:
            obj = self.get_queryset().get(PublicId=id)
        except (ObjectDoesNotExist, ValidationError, ValueError, TypeError):
            raise NotFound("Record Not Found")
        self.check_object_permissions(self.request, obj)
        return obj

    def get_queryset(self) -> AbstractManager :
        queries = self.get_queries()
        return self.serializer_class.Meta.model.objects.filter(**queries)

    def create(self, request, *args, **kwargs):
        pprint(request.data)
        serializer : AbstractModelSerializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer=serializer)
        return Response(serializer.data, HTTP_201_CREATED)

class AbstractAdministratorModelViewSet(AbstractGranteeModelViewSet):
    def get_authenticators(self):
        customAuthenticators = [IsAdministrator()]
        return customAuthenticators

class AbstractSiteManagerModelViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('patch', 'get', 'post', 'delete')
    permission_classes = (IsAuthenticated,)

    def get_authenticators(self):
        customAuthenticators = [IsSiteManager()]
        return customAuthenticators

from django.db import models
from django.utils import timezone
from core.abstract.models import AbstractManager, AbstractModel

class PermissionsManager(AbstractManager):

    pass

class AbstractPermission(AbstractModel):
    Name = models.CharField(max_length=100)
    Description = models.TextField()
    Citizens = models.ManyToManyField(to='citizen.Citizen')
    StartTime = models.DateTimeField()
    EndTime = models.DateTimeField()

    objects = PermissionsManager()
    @property
    def all_citizens(self):
        citizens : list[str] = []
        for citizen in self.Citizens:
            citizens.append(citizen.UserName)
        return citizens
    @property
    def permission_open(self):
        time = timezone.now()
        if time < self.StartTime:
            return False
        elif time > self.EndTime:
            return False
        else:
            return True

    def __str__(self):
        return f'\n\tName: {self.Name}, \n\tPermissionOpen: {self.permission_open}, \n\tCitizens: {self.Citizens}'

class AbstractLogManager(AbstractManager):
    
    pass

class AbstractLogModel(AbstractModel):
    Citizen = models.ForeignKey(to='citizen.Citizen', on_delete=models.PROTECT)
    Method = models.CharField()
    Object = models.CharField()
    RecordId = models.CharField(null=True)
    IpAddress = models.CharField(max_length=19)
    Message = models.CharField()

    objects : AbstractLogManager = AbstractLogManager()

    def __str__(self):
        return f'Log:: Citizen:{self.Citizen.UserName}, Method: {self.Method}, Record: {self.RecordId}, StatusCode: {self.StatusCode}'
    pass

from rest_framework import serializers
from core.abstract.serializers import AbstractModelSerializer
from core.citizen.models import Citizen
from core.citizen.serializers import PermissionCitizenSerializer
from core.citizen.serializers import StaffCitizenSerializer
from .models import AbstractLogModel
from .models import AbstractPermission

class AbstractPermissionSerializer(AbstractModelSerializer):
    Citizens = serializers.SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId', many=True)
    PermissionOpen = serializers.SerializerMethodField()

    def get_PermissionOpen(self, permission : AbstractPermission):
        return permission.permission_open

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Citizens'] = PermissionCitizenSerializer(instance.Citizens).data
        return data

    class Meta:
        model : AbstractPermission = AbstractPermission


class AbstractLogSerializer(AbstractModelSerializer):
    Citizen = serializers.SlugRelatedField(queryset=Citizen.objects.all(), slug_field="PublicId")

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Citizen'] = StaffCitizenSerializer(instance.Citizen).data
        return data

    class Meta:
        model : AbstractLogModel = AbstractLogModel
        fields : list[str] = [
            'id','Citizen', 'Method', 'Object', 'RecordId', 'Message', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id','Citizen', 'Method', 'Object', 'RecordId', 'Message', 'Created', 'Updated'
        ]

from core.abstract.viewset import AbstractAdministratorModelViewSet, AbstractSiteManagerModelViewSet, AbstractGranteeModelViewSet

class AdministratorLogViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('get')

class SiteManagerLogViewSet(AbstractSiteManagerModelViewSet):
    http_method_names = ('get')

class GranteeLogViewSet(AbstractGranteeModelViewSet):
    http_method_names = ('get')

from django.apps import AppConfig


class AdministratorConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.administrator'
    label = 'administrator'

from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from core.abstract.models import AbstractManager, AbstractModel
from django.core.validators import MinValueValidator, MaxValueValidator


# Create your models here.

class AdministratorManager(BaseUserManager, AbstractManager):
    pass

class Administrator(AbstractBaseUser, AbstractModel):
    AdministratorUserName = models.CharField(max_length=50, unique=True)
    Citizen = models.OneToOneField(to='citizen.Citizen', on_delete=models.PROTECT)
    FirstEmail = models.EmailField(unique=True)
    SecondEmail = models.EmailField(unique=True, null=True)
    GranteeLimit = models.IntegerField(validators=[
        MinValueValidator(10), MaxValueValidator(100)
    ])

    USERNAME_FIELD = 'AdministratorUserName'
    REQUIRED_FIELDS = ['AdministratorUserName']

    objects : AdministratorManager = AdministratorManager()

    def __str__(self):
        return f'Administrator Account: {self.AdministratorUserName}, {self.FirstEmail}, {self.SecondEmail}'


from rest_framework.serializers import CharField, SlugRelatedField
from django.contrib.auth.hashers import make_password
from core.abstract.serializers import AbstractModelSerializer
from core.citizen.serializers import StaffCitizenSerializer, Citizen
from .models import Administrator

class AdministratorModelSerializer(AbstractModelSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')
    password = CharField(max_length=128, min_length=8, write_only=True, required=True)

    class Meta:
        model : Administrator = Administrator
        fields : list[str] = [
            'id', 'AdministratorUserName', 'Citizen', 'FirstEmail', 'SecondEmail', 'password', 'GranteeLimit',
            'Created', 'Updated'
        ]

        read_only_fields :list[str] = [
            'id', 'Created', 'Updated', 'GranteeLimit', 'Citizen'
        ]

        write_only_fields : list[str] = [
            'password'
        ]
    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Citizen'] = StaffCitizenSerializer(instance.Citizen).data
        return data

class SiteManagerAdministratorModelSerializer(AdministratorModelSerializer):
    password = CharField(max_length=128, min_length=8, write_only=True, required=True)

    class Meta:
        model : Administrator = Administrator
        fields : list[str] = [
            'id', 'AdministratorUserName', 'Citizen', 'FirstEmail', 'SecondEmail', 'GranteeLimit','password',
            'Created', 'Updated'
        ]
        read_only_fields :list[str] = [
            'id', 'Created', 'Updated'
        ]

        write_only_fields : list[str] = [
            'password'
        ]

    def validate_password(self, value: str) -> str:
        return make_password(value)

from django.shortcuts import render
from rest_framework.permissions import IsAuthenticated
from rest_framework.exceptions import PermissionDenied
from core.abstract.viewset import AbstractSiteManagerModelViewSet, AbstractAdministratorModelViewSet
from .serializers import SiteManagerAdministratorModelSerializer, AdministratorModelSerializer


# Create your views here.
class AdministratorModelViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('patch', 'get')
    serializer_class = AdministratorModelSerializer

    def get_object(self):
        obj = self.request.user.administrator
        self.check_object_permissions(self.request, obj=obj)
        return obj
    
    def get_queryset(self):
        PermissionDenied('Administrators Are Not Allowed To Access This Method')

class SiteManagerAdministratorModelViewSet(AbstractSiteManagerModelViewSet):
    serializer_class = SiteManagerAdministratorModelSerializer
    http_method_names = ('patch', 'get', 'post', 'delete')
    permission_classes = (IsAuthenticated,)

from django.apps import AppConfig


class AssociationConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.association'
    label = 'association'

from django.db import models
from core.abstract.models import AbstractModel, AbstractManager

# Create your models here.
class AssociationManager(AbstractManager):

    pass

class Association(AbstractModel):
    Title = models.CharField(max_length=100, unique=True)
    Email = models.EmailField(unique=True)
    Department = models.ForeignKey(to='department.Department', on_delete=models.PROTECT)
    Description = models.TextField()
    Website = models.URLField(null=True)

    objects : AssociationManager = AssociationManager()

    @property
    def get_administrator(self):
        return self.Department.Administrator

    def __str__(self):
        return f'{self.Title}, {self.Email}, {self.Department.Administrator.AdministratorUserName}'

    pass

from rest_framework.serializers import SlugRelatedField
from core.abstract.serializers import AbstractModelSerializer
from core.department.models import Department
from core.department.serializers import AssociationDepartmentSerializer
from .models import Association

class CitizenAssociationModelSerializer(AbstractModelSerializer):
    Department = SlugRelatedField(queryset=Department.objects.all(), slug_field='PublicId')

    def to_representation(self, instance:Association):
        data = super().to_representation(instance)
        data['Department'] = AssociationDepartmentSerializer(instance.Department).data
        return data
    class Meta:
        model : Association = Association
        fields : list[str] = ['id','Title','Email','Department','Description', 'Website','Created', 'Updated']
        read_only_fields : list[str] = [
            'id','Title','Email', 'Department','Website','Description', 'Created', 'Updated'
        ]

class GranteeAssociationModelSerializer(CitizenAssociationModelSerializer):
    pass

class AdministratorAssociationModelSerializer(GranteeAssociationModelSerializer):

    class Meta:
        model : Association = Association
        fields : list[str] = ['id','Title','Email','Department','Website','Description', 'Created', 'Updated']
        read_only_fields : list[str] = [
            'id','Department', 'Created', 'Updated'
        ]

class SiteManagerAssociationModelSerializer(AdministratorAssociationModelSerializer):

    class Meta:
        model : Association = Association
        fields : list[str] = ['id','Title','Email','Department','Website','Description', 'Created', 'Updated']
        read_only_fields : list[str] = [
            'id', 'Created', 'Updated'
        ]

class PublicServiceAssociationSerializer(AbstractModelSerializer):
    Department = SlugRelatedField(queryset=Department.objects.all(), slug_field='PublicId')


    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Department'] = instance.Department.Title
        return data
    
    class Meta:
        model : Association = Association
        fields : list[str] = ['id','Title','Email','Department', 'Website']
        read_only_fields : list[str] = [
            'id','Title','Email', 'Department','Website'
        ]

class GranteeAssociationSerializer(AbstractModelSerializer):
    Department = SlugRelatedField(queryset=Department.objects.all(), slug_field='PublicId')

    class Meta:
        model : Association = Association
        fields : list[str] = ['id','Title','Email','Department', 'Website']
        read_only_fields : list[str] = [
            'id','Title','Email', 'Department','Website'
        ]
    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Department'] = instance.Department.Title
        return data

class PermissionAssociationSerializer(AbstractModelSerializer):
    Department = SlugRelatedField(queryset=Department.objects.all(), slug_field='PublicId')

    class Meta:
        model : Association = Association
        fields : list[str] = ['id','Title','Email','Department', 'Website']
        read_only_fields : list[str] = [
            'id','Title','Email', 'Department','Website'
        ]
    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Department'] = instance.Department.Title
        return data

from django.shortcuts import render
from django.db.transaction import atomic
from django.db.models import QuerySet
from django.db.utils import IntegrityError
from rest_framework.status import HTTP_201_CREATED
from rest_framework.response import Response
from rest_framework.exceptions import MethodNotAllowed, bad_request
from core.department.serializers import SiteManagerDepartmentSerializer
from core.abstract.viewset import AbstractGranteeModelViewSet, AbstractAdministratorModelViewSet, AbstractSiteManagerModelViewSet, AbstractModelViewSet
from .serializers import CitizenAssociationModelSerializer, GranteeAssociationModelSerializer, AdministratorAssociationModelSerializer, SiteManagerAssociationModelSerializer
from .models import Association
# Create your views here.
class CitizenAssociationModelViewSet(AbstractModelViewSet):
    http_method_names : tuple[str] = ('get',)
    serializer_class: CitizenAssociationModelSerializer = CitizenAssociationModelSerializer


class GranteeAssociationModelViewSet(AbstractGranteeModelViewSet):
    http_method_names = ('get',)
    serializer_class = GranteeAssociationModelSerializer

    def get_queryset(self):
        
        if hasattr(self.request.user, 'grantee'):
            grantee_association : Association = self.request.user.grantee.Association
            queries = self.get_queries()
            queries['PublicId'] = grantee_association.PublicId.hex
            # print(admin_department)
            return self.serializer_class.Meta.model.objects.filter(**queries)
        raise MethodNotAllowed

class AdministratorAssociationModelViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('get', 'patch', 'post')
    serializer_class = AdministratorAssociationModelSerializer

    def get_queryset(self):
        if hasattr(self.request.user, 'administrator'):
            if hasattr(self.request.user.administrator, 'department'):
                queries = self.get_queries()
                queries['Department'] = self.request.user.administrator.department
                # print(admin_department)
                # print(self.serializer_class.Meta.model.objects.filter(Department=admin_department))
                return self.serializer_class.Meta.model.objects.filter(**queries)
        raise MethodNotAllowed

    @atomic
    def create(self, request, *args, **kwargs):
        if hasattr(self.request.user.administrator, 'department'):
            request.data['Department'] = self.request.user.administrator.department.PublicId.hex
            serializer = SiteManagerAssociationModelSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)
            self.perform_create(serializer)
            return Response(serializer.data, HTTP_201_CREATED)
        raise MethodNotAllowed('You haven\'t been assigned to a department yet')

class SiteManagerAssociationModelViewSet(AbstractSiteManagerModelViewSet):
    http_method_names = ('get', 'patch', 'post')
    serializer_class = SiteManagerAssociationModelSerializer

    @atomic
    def create(self, request, *args, **kwargs):
        try:
                
            department = request.data.pop('Department', False)
            if not department:
                return bad_request('Missing field')
            elif type(department) == dict:
                serializer = SiteManagerDepartmentSerializer(data=department)
                serializer.is_valid(raise_exception=True)
                serializer.save()
                request.data['Department'] = serializer.data['id']
            else:
                request.data['Department'] = department
            return super().create(request, *args, **kwargs)
        except (IntegrityError) as e:
            return bad_request('Element Duplicate Element', e)


from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework_simplejwt.settings import api_settings
from rest_framework.fields import empty
from rest_framework.exceptions import AuthenticationFailed
from django.contrib.auth.models import update_last_login
from core.citizen.serializers import CitizenSerializer
from core.siteManager.serializers import SiteManagerSerializer
from core.administrator.serializers import AdministratorModelSerializer
from core.grantee.serializers import GranteeSerializer
from pprint import pprint

INVALID_DATA = {
                    'access': 'denied',
                    'code': 'bad request'
                }
class LoginCitizenSerializer(TokenObtainPairSerializer):
    

    def validate(self, attrs):
        data =  super().validate(attrs)
        refresh = self.get_token(self.user)

        data['user'] = CitizenSerializer(self.user).data
        data['refresh'] = str(refresh)
        data['access'] = str(refresh.access_token)

        if api_settings.UPDATE_LAST_LOGIN:
            update_last_login(None, self.user)

        return data

class LoginSiteManagerSerializer(TokenObtainPairSerializer):
    ManagerPassword = None
    ManagerUserName = None
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.ManagerPassword = kwargs['data']['ManagerPassword']
        self.ManagerUserName = kwargs['data']['ManagerUserName']

    def validate(self, attrs):
        data =  super().validate(attrs)
        refresh = self.get_token(self.user)
        if hasattr(self.user, 'sitemanager'):
            # ManagerPassword, ManagerUserName = attrs['ManagerPassword'], attrs['ManagerUserName']
            if self.user.sitemanager.check_password(self.ManagerPassword) and self.ManagerUserName == self.user.sitemanager.ManagerUserName:
                data['user'] = SiteManagerSerializer(self.user.sitemanager).data
                data['refresh'] = str(refresh)
                data['access'] = str(refresh.access_token)
                if api_settings.UPDATE_LAST_LOGIN:
                    update_last_login(None, self.user)
                return data


        return INVALID_DATA

    def is_valid(self, *, raise_exception=False):
        return super().is_valid(raise_exception=raise_exception)

class LoginAdministratorSerializer(TokenObtainPairSerializer):
    AdministratorPassword = None
    AdministratorUserName = None
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.AdministratorPassword = kwargs['data']['AdministratorPassword']
        self.AdministratorUserName = kwargs['data']['AdministratorUserName']

    def validate(self, attrs):
        data =  super().validate(attrs)
        refresh = self.get_token(self.user)
        if hasattr(self.user, 'administrator'):
            # ManagerPassword, ManagerUserName = attrs['ManagerPassword'], attrs['ManagerUserName']
            if self.user.administrator.check_password(self.AdministratorPassword) and self.AdministratorUserName == self.user.administrator.AdministratorUserName:
                data['user'] = AdministratorModelSerializer(self.user.administrator).data
                data['refresh'] = str(refresh)
                data['access'] = str(refresh.access_token)
                if api_settings.UPDATE_LAST_LOGIN:
                    update_last_login(None, self.user)
                return data


        return INVALID_DATA

class LoginGranteeSerializer(TokenObtainPairSerializer):
    GranteePassword = None
    GranteeUserName = None
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.GranteePassword = kwargs['data']['GranteePassword']
        self.GranteeUserName = kwargs['data']['GranteeUserName']

    def validate(self, attrs):
        data =  super().validate(attrs)
        refresh = self.get_token(self.user)
        if hasattr(self.user, 'grantee'):
            # ManagerPassword, ManagerUserName = attrs['ManagerPassword'], attrs['ManagerUserName']
            if self.user.grantee.check_password(self.GranteePassword) and self.GranteeUserName == self.user.grantee.GranteeUserName:
                data['user'] = GranteeSerializer(self.user.grantee).data
                data['refresh'] = str(refresh)
                data['access'] = str(refresh.access_token)
                if api_settings.UPDATE_LAST_LOGIN:
                    update_last_login(None, self.user)
                return data


        return INVALID_DATA


from rest_framework import serializers
from core.citizen.serializers import CitizenSerializer, Citizen

class RegisterCitizenSerializer(CitizenSerializer):
    password = serializers.CharField(max_length=128, min_length=8, write_only=True, required=True)

    class Meta:
        model = Citizen
        fields = [
            'id', 'UserName', 'Email', 'FirstName', 'SecondName', 'Surname', 'DOB', 'NationalId', 'password','is_active',
            'Updated', 'Created',
        ]
        read_only_fields = [
            'id', 'is_active', 'Created', 'Updated'
        ]
    
    def create(self, validated_data):
        return Citizen.objects.create(**validated_data)

from core.auth.serializers import LoginCitizenSerializer, LoginSiteManagerSerializer, LoginAdministratorSerializer, LoginGranteeSerializer, INVALID_DATA
from rest_framework.viewsets import ViewSet
from rest_framework.permissions import AllowAny
from rest_framework.status import HTTP_200_OK
from rest_framework.response import Response
from rest_framework.exceptions import AuthenticationFailed
from rest_framework_simplejwt.exceptions import TokenError, InvalidToken
from pprint import pprint

class LoginCitizenViewSet(ViewSet):
    serializer_class = LoginCitizenSerializer
    permission_classes = (AllowAny,)
    http_method_names = ['post']

    def create(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
        except TokenError as e:
            raise InvalidToken(e.args[0])
        return Response(serializer.validated_data, status=HTTP_200_OK)

class LoginGranteeViewSet(ViewSet):
    serializer_class = LoginGranteeSerializer
    permission_classes = (AllowAny,)
    http_method_names = ('post',)

    def create(self, request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
        except TokenError as e:
            raise InvalidToken(e.args[0])
        data = serializer.validated_data
        # if data == INVALID_DATA:
        #     AuthenticationFailed()
        return Response(serializer.validated_data, HTTP_200_OK)

class LoginAdministratorViewSet(LoginGranteeViewSet):
    serializer_class = LoginAdministratorSerializer
class LoginSiteManagerViewSet(LoginAdministratorViewSet):
    serializer_class = LoginSiteManagerSerializer
    
from rest_framework.response import Response
from rest_framework_simplejwt.views import TokenRefreshView
from rest_framework.permissions import AllowAny
from rest_framework.status import HTTP_200_OK
from rest_framework.viewsets import ViewSet
from rest_framework_simplejwt.exceptions import TokenError, InvalidToken

class RefreshViewSet(ViewSet, TokenRefreshView):
    permission_classes = (AllowAny,)
    http_method_names = ['post']

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data = request.data)
        try:
            serializer.is_valid(raise_exception=True)
        except TokenError as e:
            raise InvalidToken(e.args[0])
        return Response(serializer.validated_data, status=HTTP_200_OK)

from django.db.transaction import atomic
from rest_framework.viewsets import ViewSet
from rest_framework.status import HTTP_201_CREATED
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from core.auth.serializers import RegisterCitizenSerializer
from rest_framework.permissions import AllowAny

class RegisterViewSet(ViewSet):
    http_method_names = ['post']
    permission_classes = (AllowAny,)
    serializer_class = RegisterCitizenSerializer
    
    @atomic
    def create(self,request, *args, **kwargs):
        serializer = self.serializer_class(data=request.data)
        serializer.is_valid(raise_exception=True)
        citizen = serializer.save()
        refresh = RefreshToken.for_user(citizen)
        return Response({
            "citizen": serializer.data,
            "refresh": str(refresh),
            "access": str(refresh.access_token),
        }, status=HTTP_201_CREATED)


from django.apps import AppConfig


class AuthConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.auth'
    label = 'auth_citizen'
from django.apps import AppConfig


class CitizenConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.citizen'
    label = 'citizen'
from django.db import models
import uuid
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.core.exceptions import ObjectDoesNotExist
from rest_framework.exceptions import NotFound

# Create your models here.
class CitizenManager(BaseUserManager):
    def get_by_id(self, id):
        try:
            instance = self.get(PublicId=id)
            return instance
        except (ObjectDoesNotExist, ValueError, TypeError):
            raise NotFound('Could Not Find User')

    def create_user(self, UserName,Email, FirstName,Surname,NationalId,DOB,SecondName=None, password=None, **kwargs):
        """Create and return a `User` with an email, phone number, username and password."""
        if UserName is None: raise TypeError('Users must have a username.')
        if FirstName is None: raise TypeError('Users must have a first name .')
        if Surname is None: raise TypeError('Users must have a surname.')
        if NationalId is None: raise TypeError('Users must have a national identification number.')
        if DOB is None: raise TypeError('users must have a date of birth(DOB)')
        if Email is None: raise TypeError('Users must have an email.')
        if password is None: raise TypeError('User must have an email.')
        user = self.model(UserName=UserName, Email=self.normalize_email(Email), FirstName=FirstName, SecondName=SecondName,Surname=Surname,NationalId=NationalId,DOB=DOB, **kwargs)
        user.set_password(password)
        user.save(using=self._db)
        return user
    
class Citizen(AbstractBaseUser, PermissionsMixin):
    PublicId = models.UUIDField(unique=True, db_index=True, editable=False,default=uuid.uuid4)
    UserName = models.CharField(max_length=100, unique=True)
    FirstName = models.CharField(max_length=100)
    SecondName = models.CharField(max_length=100, null=True)
    Surname = models.CharField(max_length=100)
    NationalId = models.CharField(max_length=40)
    DOB = models.DateTimeField()
    Email = models.EmailField(unique=True)
    EmailVerified = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    is_superuser = models.BooleanField(default=False)
    Created = models.DateTimeField(auto_now_add=True)
    Updated = models.DateTimeField(auto_now=True)

    USERNAME_FIELD = 'Email'
    REQUIRED_FIELDS = ['UserName']

    objects: CitizenManager = CitizenManager()

    def __str__(self):
        return f'{self.UserName}, {self.Email}'
from rest_framework import serializers
from django.contrib.auth.hashers import make_password
from core.abstract.serializers import AbstractModelSerializer
from .models import Citizen

class CitizenSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='PublicId', read_only=True, format='hex')
    password = serializers.CharField(max_length=128, min_length=8, write_only=True, required=True)
    Created = serializers.DateTimeField(read_only=True)
    Updated = serializers.DateTimeField(read_only=True)

    def validate_password(self, value: str) -> str:
        return make_password(value)
    class Meta:
        model : Citizen = Citizen
        fields = [
            'id', 'UserName', 'Email', 'FirstName', 'SecondName', 'Surname', 'DOB', 'NationalId', 'password','is_active',
            'Updated', 'Created',
        ]
        read_only_fields = [
            'id', 'is_active', 'Created', 'Updated'
        ]

class GranteeCitizenModelSerializer(CitizenSerializer):
    class Meta:
        model : Citizen = Citizen
        fields = [
            'id', 'UserName', 'Email', 'FirstName', 'SecondName', 'Surname', 'DOB', 'NationalId','is_active',
            'Updated', 'Created',
        ]
        read_only_fields = [
            'id', 'UserName', 'Email', 'FirstName', 'SecondName', 'Surname', 'DOB', 'NationalId','is_active',
            'Updated', 'Created',
        ]

class AdministratorCitizenModelSerializer(GranteeCitizenModelSerializer):
    pass

class SiteManagerCitizenModelSerializer(AdministratorCitizenModelSerializer):
    pass

class StaffCitizenSerializer(AbstractModelSerializer):

    class Meta:
        model : Citizen = Citizen
        fields : list[str] = [
            'id', 'UserName', 'NationalId'
        ]
        read_only_fields : list[str] = [
            'id', 'UserName', 'NationalId'
        ]

class RequestCitizenSerializer(AbstractModelSerializer):
    class Meta:
        model : Citizen = Citizen
        fields : list[str] = [
            'id', 'UserName','Email', 'FirstName', 'SecondName',
        ]
        read_only_fields : list[str] = [
            'id', 'UserName','Email', 'FirstName', 'SecondName',
        ]
class PermissionCitizenSerializer(AbstractModelSerializer):
    class Meta:
        model : Citizen = Citizen
        fields : list[str] = [
            'id', 'UserName','Email', 'FirstName', 'SecondName',
        ]
        read_only_fields : list[str] = [
            'id', 'UserName','Email', 'FirstName', 'SecondName',
        ]
class ServiceSessionCitizenSerializer(AbstractModelSerializer):

    class Meta:
        model : Citizen = Citizen
        fields : list[str] = [
            'id', 'UserName', 'Email', 'FirstName', 'SecondName', 'NationalId'
        ]
        read_only_fields : list[str] = [
            'id', 'UserName','Email', 'FirstName', 'SecondName', 'NationalId'
        ]

from django.shortcuts import render
from rest_framework.viewsets import ModelViewSet
from rest_framework.exceptions import NotFound, PermissionDenied, server_error, MethodNotAllowed
from rest_framework.permissions import AllowAny, IsAuthenticated, IsAuthenticatedOrReadOnly
from core.abstract.viewset import AbstractSiteManagerModelViewSet, AbstractAdministratorModelViewSet, AbstractGranteeModelViewSet
from .serializers import CitizenSerializer, GranteeCitizenModelSerializer, AdministratorCitizenModelSerializer, SiteManagerCitizenModelSerializer
from .models import Citizen
from pprint import pprint
# Create your views here.

class CitizenViewSet(ModelViewSet):
    serializer_class = CitizenSerializer
    permission_classes = (IsAuthenticated,)
    http_method_names = ('get', 'patch')

    def update(self, request, *args, **kwargs):
        pprint(request.data)
        obj = super().update(request, *args, **kwargs)
        pprint(obj)
        return obj
    def get_queryset(self):
        raise PermissionDenied()

    def get_object(self):
        # id = self.kwargs['pk']
        # citizen = Citizen.objects.get_by_id(id)
        citizen = self.request.user
        try:
            self.check_object_permissions(self.request, citizen)
        except:
            server_error()
        return citizen
    def create(self, request, *args, **kwargs):
        raise MethodNotAllowed("This Endpoint Is not allowed")

class GranteeCitizenModelViewSet(AbstractGranteeModelViewSet):
    http_method_names = ('get')
    serializer_class = GranteeCitizenModelSerializer


class AdministratorCitizenModelViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('get', 'patch')
    serializer_class = AdministratorCitizenModelSerializer
class SiteManagerCitizenModelViewSet(AbstractSiteManagerModelViewSet):
    http_method_names = ('get')
    permission_classes = (IsAuthenticated,)
    serializer_class = SiteManagerCitizenModelSerializer



from django.apps import AppConfig


class DepartmentConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.department'
    label = 'department'

from django.db import models
from core.abstract.models import AbstractManager, AbstractModel

# Create your models here.
class DepartmentManager(AbstractManager):
    pass

class Department(AbstractModel):
    Title = models.CharField(max_length=100, unique=True)
    Administrator = models.OneToOneField(to='administrator.Administrator', on_delete=models.PROTECT)
    Description = models.TextField()
    Email = models.EmailField(unique=True)
    Telephone = models.CharField(unique=True)
    Website = models.URLField(unique=True)

    objects : DepartmentManager = DepartmentManager()

    def __str__(self):
        return f'{self.Title}, {self.Administrator.AdministratorUserName}, {self.Email}'
    
from core.abstract.serializers import AbstractModelSerializer
from rest_framework.serializers import SlugRelatedField
from core.administrator.models import Administrator
from .models import Department

class CitizenDepartmentSerializer(AbstractModelSerializer):
    Administrator = SlugRelatedField(queryset=Administrator.objects.all(), slug_field="PublicId")

    class Meta:
        model : Department = Department
        fields : list[str] = [
            'id', 'Title', 'Email', 'Administrator','Telephone', 'Website','Description', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Title', 'Email', 'Administrator','Telephone', 'Website','Description', 'Created', 'Updated'
        ]

class GranteeDepartmentSerializer(CitizenDepartmentSerializer):

    pass

class AdministratorDepartmentSerializer(GranteeDepartmentSerializer):

    pass

class SiteManagerDepartmentSerializer(AdministratorDepartmentSerializer):


    class Meta:
        model : Department = Department
        fields : list[str] = [
            'id', 'Title', 'Email', 'Administrator', 'Telephone', 'Website', 'Description', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id','Created', 'Updated'
        ]

class AssociationDepartmentSerializer(CitizenDepartmentSerializer):

    class Meta:
        model:Department = Department
        fields : list[str] =  [
            'id', 'Title', 'Email', 'Telephone', 'Website'
        ]
        read_only_fields : list[str] = [
            'id', 'Title', 'Email', 'Telephone', 'Website'
        ]

class PermissionDepartmentSerializer(CitizenDepartmentSerializer):

    class Meta:
        model:Department = Department
        fields : list[str] =  [
            'id', 'Title', 'Email', 'Telephone', 'Website'
        ]
        read_only_fields : list[str] = [
            'id', 'Title', 'Email', 'Telephone', 'Website'
        ]

from django.shortcuts import render
from django.db.transaction import atomic
from rest_framework.exceptions import bad_request, MethodNotAllowed
from core.administrator.serializers import SiteManagerAdministratorModelSerializer
from core.abstract.viewset import AbstractModelViewSet, AbstractAdministratorModelViewSet, AbstractSiteManagerModelViewSet, AbstractGranteeModelViewSet
from .serializers import CitizenDepartmentSerializer, GranteeDepartmentSerializer, AdministratorDepartmentSerializer, SiteManagerDepartmentSerializer

# Create your views here.

class CitizenDepartmentViewSet(AbstractModelViewSet):
    http_method_names = ('get',)
    serializer_class = CitizenDepartmentSerializer
    pass

class GranteeDepartmentViewSet(AbstractGranteeModelViewSet):
    http_method_names = ('get')
    serializer_class = GranteeDepartmentSerializer

class AdministratorDepartmentViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('get', 'patch')
    serializer_class = AdministratorDepartmentSerializer
    
    def get_queryset(self):
        if hasattr(self.request.user.administrator, 'department'):
            queries = self.get_queries()
            queries['PublicId'] = self.request.user.administrator.department.PublicId.hex
            return self.serializer_class.Meta.model.objects.filter(**queries)
        return MethodNotAllowed("Get")
class SiteManagerDepartmentViewSet(AbstractSiteManagerModelViewSet):

    serializer_class = SiteManagerDepartmentSerializer


    @atomic
    def create(self, request, *args, **kwargs):
        administrator = request.data.pop('Administrator', False)
        if not administrator:
            bad_request('Administrator Field is missing')
        elif type(administrator) == dict :
            serializer = SiteManagerAdministratorModelSerializer(data=administrator)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            request.data['Administrator'] = serializer.data['id']
        else:
            request.data['Administrator'] = administrator
        return super().create(request, *args, **kwargs)
from django.apps import AppConfig


class GrantConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.grant'
    label = 'grant'
from django.db import models
from django.utils import timezone
from datetime import datetime
from core.abstract.models import AbstractManager, AbstractModel

# Create your models here.
class GrantManager(AbstractManager):
    pass

class Grant(AbstractModel):
    Message = models.CharField(max_length=300)
    Request = models.OneToOneField(to='request.Request', on_delete=models.PROTECT)
    Grantee = models.ForeignKey(to='grantee.Grantee', on_delete=models.PROTECT, null=True)
    Decline = models.BooleanField(default=False)
    StartDate = models.DateTimeField(null=True)
    EndDate = models.DateTimeField(null=True)

    objects : GrantManager = GrantManager()

    @property
    def granted(self):
        now = timezone.now()
        if self.Decline:
            return False
        elif self.StartDate == None:
            return False
        elif self.StartDate > now:
            return False
        elif self.EndDate < now:
            return False
        elif self.EndDate == None:
            return True
        return True

    def __str__(self):
        if self.Grantee:
            grantee = self.Grantee.GranteeUserName
        else:
            grantee = "N/A"
        return f'Grant: {self.Request.PublicId}, GranteeUserName-{grantee}, Decline:: {self.Decline}, Granted:: {self.granted}'

from rest_framework.serializers import SlugRelatedField, SerializerMethodField
from pprint import pprint
from core.abstract.serializers import AbstractModelSerializer
from core.request.models import Request
from core.request.serializers import GrantRequestSerializer
from core.grantee.models import Grantee
from core.grantee.serializers import GrantGranteeSerializer
from .models import Grant

class CitizenGrantSerializer(AbstractModelSerializer):
    Request = SlugRelatedField(queryset=Request.objects.all(), slug_field="PublicId")
    Granted = SerializerMethodField()

    def get_Granted(self, grant:Grant):
        return grant.granted

    def to_representation(self, instance : Grant):
        data = super().to_representation(instance)
        data['Request'] = GrantRequestSerializer(instance.Request).data
        return data
    class Meta:
        model : Grant = Grant
        fields : list[str] = [
            'id', 'Request', 'Decline', 'Granted', 'StartDate', 'EndDate', 'Message', 'Created', 'Updated'
        ]
        read_only_field : list[str] = [
            'id', 'Request', 'Decline', 'Granted', 'StartDate', 'EndDate', 'Message', 'Created', 'Updated'

        ]
    
class GranteeGrantSerializer(CitizenGrantSerializer):
    Grantee = SlugRelatedField(queryset=Grantee.objects.all(), slug_field="PublicId")

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Grantee'] = GrantGranteeSerializer(instance.Grantee).data
        pprint(data)
        return data

    class Meta:
        model : Grant = Grant
        fields : list[str] = [
            'id', 'Request', 'Grantee', 'Decline', 'Granted', 'StartDate', 'EndDate', 'Message', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Request', 'Created', 'Updated'
        ]

class AdministratorGrantSerializer(GranteeGrantSerializer):

    class Meta:
        model : Grant = Grant
        fields : list[str] = [
            'id', 'Request', 'Grantee', 'Decline', 'Granted', 'StartDate', 'EndDate', 'Message', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Request', 'Grantee', 'Decline', 'Granted', 'StartDate', 'EndDate', 'Message', 'Created', 'Updated'
        ]

class SiteManagerGrantSerializer(GranteeGrantSerializer):

    class Meta:
        model : Grant = Grant
        fields : list[str] = [
            'id', 'Request', 'Grantee', 'Decline', 'Granted', 'StartDate', 'EndDate', 'Message', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Request', 'Grantee', 'Decline', 'Granted', 'StartDate', 'EndDate', 'Message', 'Created', 'Updated'
        ]
from django.shortcuts import render
from rest_framework.exceptions import MethodNotAllowed
from core.abstract.viewset import AbstractModelViewSet, AbstractGranteeModelViewSet, AbstractAdministratorModelViewSet, AbstractSiteManagerModelViewSet
from core.request.models import Request
from core.department.models import Department
from core.association.models import Association
from .serializers import CitizenGrantSerializer, GranteeGrantSerializer, AdministratorGrantSerializer, SiteManagerGrantSerializer
from .models import Grant
# Create your views here.
class CitizenGrantViewSet(AbstractModelViewSet):
    serializer_class = CitizenGrantSerializer
    http_method_names = ('get')

    def get_queryset(self):
        queries = self.get_queries()
        queries['Request__Citizen'] = self.request.user
        return super().get_queryset().filter(**queries)

class GranteeGrantViewSet(AbstractGranteeModelViewSet):
    serializer_class = GranteeGrantSerializer
    http_method_names = ('get', 'patch')

    def get_queryset(self):
        if hasattr(self.request.user, 'grantee'):
            request = Request.objects.filter(PublicService__Grantee=self.request.user.grantee)
            queries = self.get_queries()
            queries['Request__in'] = request
            return self.serializer_class.Meta.model.objects.filter(**queries)
        else:
            raise MethodNotAllowed("GET")

    def update(self, request, *args, **kwargs):
        if hasattr(self.request.user, 'grantee'):
            request.data['Grantee'] = self.request.user.grantee.PublicId.hex
            return super().update(request, *args, **kwargs)
        else:
            raise MethodNotAllowed("PATCH")

class AdministratorGrantViewSet(AbstractAdministratorModelViewSet):
    serializer_class = AdministratorGrantSerializer
    http_method_names = ('get')

    def get_queryset(self):
        if hasattr(self.request.user, 'administrator'):
            department = Department.objects.get(Administrator=self.request.user.administrator)
            associations = Association.objects.filter(Department=department)
            requests = Request.objects.filter(PublicService__Association__in=associations)
            queries = self.get_queries()
            queries['Request__in'] = requests
            return self.serializer_class.Meta.model.objects.filter(**queries)
        else:
            raise MethodNotAllowed("GET")

class SiteManagerGrantViewSet(AbstractSiteManagerModelViewSet):
    serializer_class = SiteManagerGrantSerializer
    http_method_names = ('get')

from django.apps import AppConfig


class GranteeConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.grantee'
    label = 'grantee'

from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from core.abstract.models import AbstractModel, AbstractManager

class GranteeManager(AbstractManager):

    def create(self, **kwargs):
        if hasattr(kwargs['Administrator'], 'department'):
            if kwargs["Association"].Department == kwargs['Administrator'].department:
                return super().create(**kwargs)
    pass

# Create your models here.
class Grantee(AbstractBaseUser, AbstractModel):
    GranteeUserName = models.CharField(max_length=50, unique=True)
    Citizen = models.OneToOneField(to='citizen.Citizen', on_delete=models.PROTECT)
    Administrator = models.ForeignKey(to='administrator.Administrator', on_delete=models.PROTECT)
    Association = models.ForeignKey(to='association.Association', on_delete=models.DO_NOTHING)
    FirstEmail = models.EmailField(unique=True)
    SecondEmail = models.EmailField(unique=True, null=True)

    objects : GranteeManager = GranteeManager()
    USERNAME_FIELD = 'GranteeUserName'
    REQUIRED_FIELDS = ['GranteeUserName', 'Citizen', 'FirstEmail']
    def __str__(self):
        return f'Grantee Account: {self.GranteeUserName}, {self.FirstEmail}, {self.SecondEmail}'
from rest_framework.serializers import CharField, SlugRelatedField
from rest_framework.serializers import raise_errors_on_nested_writes
from rest_framework.utils import model_meta
from rest_framework.exceptions import ValidationError
from django.contrib.auth.hashers import make_password
from core.abstract.serializers import AbstractModelSerializer
from core.citizen.serializers import StaffCitizenSerializer, Citizen
from core.administrator.models import Administrator
from core.association.models import Association
from core.association.serializers import GranteeAssociationSerializer
from .models import Grantee

class GranteeSerializer(AbstractModelSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')
    Administrator = SlugRelatedField(queryset=Administrator.objects.all(), slug_field='PublicId')
    Association = SlugRelatedField(queryset=Association.objects.all(), slug_field='PublicId')
    password = CharField(max_length=128, min_length=8, write_only=True, required=True)

    def validate_password(self, value: str) -> str:
        return make_password(value)
    
    def update(self, instance : Grantee, validated_data):
        raise_errors_on_nested_writes('update', self, validated_data)
        info = model_meta.get_field_info(instance)

        # Simply set each attribute on the instance, and then save it.
        # Note that unlike `.create()` we don't need to treat many-to-many
        # relationships as being a special case. During updates we already
        # have an instance pk for the relationships to be associated with.
        m2m_fields = []
        for attr, value in validated_data.items():
            if attr in info.relations and info.relations[attr].to_many:
                m2m_fields.append((attr, value))
            else:
                setattr(instance, attr, value)
        if hasattr(instance.Administrator, 'department'):
            if instance.Association.Department == instance.Administrator.department:
                instance.save()

                # Note that many-to-many fields are set after updating instance.
                # Setting m2m fields triggers signals which could potentially change
                # updated instance and we do not want it to collide with .update()
                for attr, value in m2m_fields:
                    field = getattr(instance, attr)
                    field.set(value)

                return instance
        raise ValidationError("administrator and association do not match")

    class Meta:
        model : Grantee = Grantee
        fields : list[str] = [
             'id','GranteeUserName', 'Association', 'Administrator', 'Citizen', 'FirstEmail', 'SecondEmail','password',
            'Created', 'Updated'
        ]
        write_only_fields : list[str] = [
            'password'
        ]
        read_only_fields : list[str] = [
            'id', 'Citizen', 'Association', 'Administrator', 'Created', 'Updated'
        ]

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Citizen'] = StaffCitizenSerializer(instance.Citizen).data
        data['Association'] = GranteeAssociationSerializer(instance.Association).data
        return data

class AdministratorGranteeSerializer(GranteeSerializer):
    password = CharField(max_length=128, min_length=8, write_only=True, required=True)
    
    class Meta:
        model : Grantee = Grantee
        fields : list[str] = [
             'id', 'GranteeUserName','Association',  'Administrator', 'Citizen', 'FirstEmail', 'SecondEmail','password',
            'Created', 'Updated'
        ]

        read_only_fields : list[str] = [
            'id', 'Created', 'Updated'
        ]

class SiteManagerGranteeSerializer(AdministratorGranteeSerializer):
    class Meta:
        model : Grantee = Grantee
        fields : list[str] = [
             'id', 'GranteeUserName', 'Association', 'Administrator', 'Citizen', 'FirstEmail', 'SecondEmail','password',
            'Created', 'Updated'
        ]

        read_only_fields : list[str] = [
            'id', 'Created', 'Updated'
        ]

class PublicServiceGranteeSerializer(AbstractModelSerializer):

    class Meta:
        model: Grantee = Grantee
        fields : list[str] = [
            'id', 'GranteeUserName'
        ]
        read_only_fields : list[str] = [
            'id', 'GranteeUserName'
        ]

class GrantGranteeSerializer(AbstractModelSerializer):

    class Meta:
        model: Grantee = Grantee
        fields : list[str] = [
            'id', 'GranteeUserName'
        ]
        read_only_fields : list[str] = [
            'id', 'GranteeUserName'
        ]
from django.shortcuts import render
from rest_framework.exceptions import PermissionDenied
from core.abstract.viewset import AbstractGranteeModelViewSet, AbstractAdministratorModelViewSet, AbstractSiteManagerModelViewSet
from core.association.models import Association
from .serializers import GranteeSerializer, AdministratorGranteeSerializer, SiteManagerGranteeSerializer

# Create your views here.
class GranteeModelsViewSet(AbstractGranteeModelViewSet):
    http_method_names = ('patch', 'get')
    serializer_class = GranteeSerializer

    def get_object(self):
        obj = self.request.user.grantee
        self.check_object_permissions(self.request, obj)
        return obj
    
    def get_queryset(self): #get grantees from the same association
        queries = self.get_queries()
        queries['PublicId'] = self.request.user.grantee.PublicId
        return self.serializer_class.Meta.model.objects.filter(**queries)

class AdministratorGranteeViewSet(AbstractAdministratorModelViewSet):
    serializer_class = AdministratorGranteeSerializer
    http_method_names = ('patch', 'get', 'post', 'delete')

    def get_queryset(self):
        if hasattr(self.request.user.administrator, 'department' ):
            department = self.request.user.administrator.department
            associations = Association.objects.filter(Department=department)
            queries = self.get_queries()
            queries['Association__in'] = associations
            return self.serializer_class.Meta.model.objects.filter(**queries)
        return PermissionDenied('You do not have a department')

    def create(self, request, *args, **kwargs):
        request.data['Administrator'] = self.request.user.administrator.PublicId.hex
        return super().create(request, *args, **kwargs)
    pass

class SiteManagerGranteeViewSet(AbstractSiteManagerModelViewSet):
    serializer_class = SiteManagerGranteeSerializer
    http_method_names = ('patch', 'get', 'post', 'delete')


from django.apps import AppConfig


class PublicserviceConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.publicService'
    label = 'publicService'

from django.db import models
from rest_framework.exceptions import ValidationError
from django.contrib.postgres.fields import ArrayField
from core.abstract.models import AbstractManager, AbstractModel
# from core.grantee.models import Grantee
from pprint import pprint

# Create your models here.
class PublicServiceManager(AbstractManager):

    def create(self, **kwargs):
        pprint(kwargs)
        for grantee in kwargs['Grantee'] :
            if kwargs['Association'] != grantee.Association: raise ValidationError("Association and Grantee Do not match")
        grantee = kwargs.pop('Grantee', [])
        model : PublicService = self.model(**kwargs)
        pprint(grantee)
        # model.Grantee.set(grantee)
        model.save(using=self._db)
        model.Grantee.set(grantee)
        model.save(using=self._db)
        return model

    pass

ALLOWED_METHODS = ['GET', 'POST', 'DELETE', 'PATCH']
DEFAULT_ALLOWED_METHODS = ['GET', 'POST', 'PATCH']
def default_methods():
    return [(m, m) for m in DEFAULT_ALLOWED_METHODS]

class Methods(models.Model):
    name = models.CharField(choices=default_methods(), unique=True)
class PublicService(AbstractModel):
    Title = models.CharField(max_length=100, unique=True)
    MachineName = models.CharField(max_length=150, unique=True)
    Description = models.TextField()
    Email = models.EmailField(unique=True)
    Grantee = models.ManyToManyField(to='grantee.Grantee')
    Association = models.ForeignKey(to='association.Association', on_delete=models.PROTECT)
    Methods = models.ManyToManyField(to=Methods, null=True)
    Restricted = models.BooleanField(default=False)
    URL = models.URLField(unique=True)
    Visibility = models.BooleanField(default=True)


    objects : PublicServiceManager = PublicServiceManager()

    @property
    def get_grantee(self):
        text = ''
        pprint(self.Grantee)
        for grantee in self.Grantee.all():
            text += f'\n\t\t {grantee.GranteeUserName}'
        pprint(text).__str__
        return text

    def __str__(self):
        return f'PublicService: \n\t{self.Title}, \n\tAssociation({self.Association}), \n\tEmail({self.Email}, \n\tGrantee({self.get_grantee}))'

from rest_framework.serializers import SlugRelatedField, raise_errors_on_nested_writes
from rest_framework.exceptions import ValidationError
from rest_framework.utils import model_meta
from core.abstract.serializers import AbstractModelSerializer
from core.association.models import Association
from core.association.serializers import PublicServiceAssociationSerializer
from core.grantee.models import Grantee
from core.grantee.serializers import PublicServiceGranteeSerializer
from .models import PublicService, Methods
from pprint import pprint

class CitizenPublicServiceSerializer(AbstractModelSerializer):
    Association = SlugRelatedField(queryset=Association.objects.all(), slug_field='PublicId')
    
    def to_representation(self, instance:PublicService):
        data = super().to_representation(instance)
        data['Association'] = PublicServiceAssociationSerializer(instance.Association).data
        return data

    def update(self, instance : PublicService, validated_data):
        raise_errors_on_nested_writes('update', self, validated_data)
        info = model_meta.get_field_info(instance)

        # Simply set each attribute on the instance, and then save it.
        # Note that unlike `.create()` we don't need to treat many-to-many
        # relationships as being a special case. During updates we already
        # have an instance pk for the relationships to be associated with.
        m2m_fields = []
        for attr, value in validated_data.items():
            if attr in info.relations and info.relations[attr].to_many:
                m2m_fields.append((attr, value))
            else:
                setattr(instance, attr, value)
        granteeError = []
        for grantee in instance.Grantee.all():
            if grantee.Association != instance.Association:
                granteeError.append(grantee)
        if len(granteeError) <= 0:

            instance.save()

            # Note that many-to-many fields are set after updating instance.
            # Setting m2m fields triggers signals which could potentially change
            # updated instance and we do not want it to collide with .update()
            for attr, value in m2m_fields:
                field = getattr(instance, attr)
                field.set(value)

            return instance
        raise ValidationError("Grantee does not belong to the association: %s", granteeError)

    def create(self, validated_data):
        return self.Meta.model.objects.create(**validated_data)
    class Meta:
        model : PublicService = PublicService
        fields : list[str] = [
            'id','Title', "MachineName", 'Email', 'Association','Restricted', 'Description', 'URL', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id','Title', "MachineName", 'Email', 'Association','Restricted', 'Description', 'URL', 'Created', 'Updated'
        ]

class GranteePublicServiceSerializer(CitizenPublicServiceSerializer):
    Grantee = SlugRelatedField(queryset=Grantee.objects.all(), slug_field='PublicId', many=True)
    Methods = SlugRelatedField(queryset=Methods.objects.all(), slug_field='name', many=True)

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Grantee'] = [ PublicServiceGranteeSerializer(grantee).data for grantee in instance.Grantee.all()]
        return data
    class Meta:
        model : PublicService = PublicService
        fields : list[str] = [
            'id','Title', "MachineName", 'Email', 'Association','Restricted', 'Methods', 'Description', 'URL', 'Grantee', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id','Title', "MachineName", 'Email', 'Association','Restricted', 'Methods', 'Description', 'URL', 'Grantee', 'Created', 'Updated'
        ]
    pass

class AdministratorPublicServiceSerializer(GranteePublicServiceSerializer):
    class Meta:
        model : PublicService = PublicService
        fields : list[str] = [
            'id','Title', "MachineName", 'Email', 'Association', 'Description', 'URL', 'Grantee', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Created', 'Updated'
        ]
    pass

class SiteManagerPublicServiceSerializer(AdministratorPublicServiceSerializer):
    pass

class RequestPublicServiceSerializer(AbstractModelSerializer):

    class Meta:
        model : PublicService = PublicService
        fields : list[str] = [
            'id','Title', "MachineName", 'URL'
        ]
        read_only_fields : list[str] =  [
            'id','Title', "MachineName", 'URL'
        ]

class PermissionPublicServiceSerializer(AbstractModelSerializer):

    class Meta:
        model : PublicService = PublicService
        fields : list[str] = [
            'id','Title', "MachineName", 'URL'
        ]
        read_only_fields : list[str] =  [
            'id','Title', "MachineName", 'URL'
        ]


class ServiceSessionPublicServiceSerializer(AbstractModelSerializer):

    class Meta:
        model : PublicService = PublicService
        fields : list[str] = [
            'id','Title', "MachineName", 'URL'
        ]
        read_only_fields : list[str] =  [
            'id','Title', "MachineName", 'URL'
        ]
from django.shortcuts import render
from django.db.transaction import atomic
from django.core.exceptions import ObjectDoesNotExist, ValidationError as ValidationError_Django
from rest_framework.exceptions import ValidationError, MethodNotAllowed, NotFound
from core.association.models import Association
from core.abstract.viewset import AbstractModelViewSet, AbstractGranteeModelViewSet, AbstractAdministratorModelViewSet, AbstractSiteManagerModelViewSet
from core.association.serializers import AdministratorAssociationModelSerializer, SiteManagerAssociationModelSerializer
from core.association.models import Association
from core.grantee.serializers import AdministratorGranteeSerializer, SiteManagerGranteeSerializer
from core.servicePermissions.models import AssociationPermission, DepartmentPermission, PublicServicePermission
from .serializers import CitizenPublicServiceSerializer, GranteePublicServiceSerializer, AdministratorPublicServiceSerializer, SiteManagerPublicServiceSerializer
# Create your views here.
class CitizenPublicServiceViewSet(AbstractModelViewSet):
    http_method_names : tuple[str] = ('get',)
    serializer_class = CitizenPublicServiceSerializer
    def get_object(self):
        id = self.kwargs['pk']
        obj = None
        for func in [self.getQ_PublicService_Association, self.getQ_PublicService_Department, self.getQ_PublicService_Restricted, self.getQ_PublicService_Service]:
            try:
                obj = func().get(PublicId=id)
                if obj:break
            except (ObjectDoesNotExist, ValidationError_Django, ValueError, TypeError):
                continue
        if obj:
            self.check_object_permissions(self.request, obj)
            return obj
        raise NotFound("Service Not Found")

    def getQ_PublicService_Service(self):
        publicServicePermissions = PublicServicePermission.objects.filter(Citizens=self.request.user)
        publicServices = []
        for permission in publicServicePermissions:
            publicServices.append(permission.PublicId.hex)
        queries = self.get_queries()
        queries["PublicId__in"] = publicServices
        return self.serializer_class.Meta.model.objects.filter(**queries)

    def getQ_PublicService_Association(self):
        associationPermission = AssociationPermission.objects.filter(Citizens=self.request.user)
        associations = []
        for permission in associationPermission:
            associations.append(permission.Association)
        queries = self.get_queries()
        queries["Association__in"] = associations
        return self.serializer_class.Meta.model.objects.filter(**queries)

    def getQ_PublicService_Department(self):
        departmentPermissions = DepartmentPermission.objects.filter(Citizens=self.request.user)
        departments = []
        for permission in departmentPermissions:
            departments.append(permission.Department)
        associations = Association.objects.filter(Department__in=departments)
        queries = self.get_queries()
        queries["Association__in"] = associations
        return self.serializer_class.Meta.model.objects.filter(**queries)
    
    def getQ_PublicService_Restricted(self):
        return self.serializer_class.Meta.model.objects.filter(Restricted=False)

    def get_queryset(self):
        by_association_permission = self.getQ_PublicService_Association()
        by_department_permission = self.getQ_PublicService_Department()
        by_service_permission = self.getQ_PublicService_Service()
        by_publicity = self.getQ_PublicService_Restricted()
        return by_publicity.union(by_department_permission).union(by_association_permission).union(by_service_permission)


class GranteePublicServiceViewSet(AbstractGranteeModelViewSet):
    http_method_names : tuple[str] = ('get',)
    serializer_class = GranteePublicServiceSerializer

    def get_queryset(self):
        queries = self.get_queries()
        queries['Grantee'] = self.request.user.grantee
        return self.serializer_class.Meta.model.objects.filter(**queries)

class AdministratorPublicServiceViewSet(AbstractAdministratorModelViewSet):
    http_method_names : tuple[str] = ('get', 'patch', 'post', 'delete')
    serializer_class = AdministratorPublicServiceSerializer

    def get_queryset(self):
        if hasattr(self.request.user.administrator, 'department'):
            department = self.request.user.administrator.department
            associations = Association.objects.filter(Department=department)
            queries = self.get_queries()
            queries['Association__in'] = associations
            return self.serializer_class.Meta.model.objects.filter(**queries)
        raise MethodNotAllowed('GET')
    @atomic
    def create(self, request, *args, **kwargs):
        association = request.data.pop('Association', False)
        grantee = request.data.pop('Grantee', False)
        if not association:
            raise ValidationError("Association missing")
        elif type(association) == dict:
            association = self.secondary_create(AdministratorAssociationModelSerializer, association)
        if not grantee:
            raise ValidationError("Grantee is missing")
        elif type(grantee) == dict:
            grantee = self.secondary_create(AdministratorGranteeSerializer, grantee)
        request.data['Association'] = association
        request.data['Grantee'] = grantee
        return super().create(request, *args, **kwargs)

class SiteManagerPublicServiceViewSet(AbstractSiteManagerModelViewSet):
    http_method_names : tuple[str] = ('get', 'patch', 'post', 'delete')
    serializer_class = SiteManagerPublicServiceSerializer
    @atomic
    def create(self, request, *args, **kwargs):
        association = request.data.pop('Association', False)
        grantee = request.data.pop('Grantee', False)
        if not association:
            raise ValidationError("Association is missing")
        elif type(association) == dict:
            association = self.secondary_create(SiteManagerAssociationModelSerializer, association)
        if not grantee:
            raise ValidationError("Grantee is missing")
        elif type(grantee) == dict:
            grantee = self.secondary_create(SiteManagerGranteeSerializer, grantee)
        request.data['Association'] = association
        request.data['Grantee'] = grantee
        return super().create(request, *args, **kwargs)

from django.apps import AppConfig


class RequestConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.request'
    label = 'request'
from django.db import models
from django.db.transaction import atomic
from rest_framework.exceptions import APIException
from core.abstract.models import AbstractManager, AbstractModel
from core.grant.models import Grant

# Create your models here.
class RequestManager(AbstractManager):

    @atomic
    def create(self, **kwargs):
        try:
            request = super().create(**kwargs)
            grant_data = {
                "Request": request,
                "Message": "N/A"
            }
            grant = Grant.objects.create(**grant_data)
            return request
        except:
            raise APIException('Failed to create request')
    pass

class Request(AbstractModel):
    Subject = models.CharField(max_length=50)
    Citizen = models.ForeignKey(to='citizen.Citizen', on_delete=models.PROTECT)
    PublicService = models.ForeignKey(to='publicService.PublicService', on_delete=models.PROTECT)
    Message = models.CharField(max_length=500)

    objects : RequestManager = RequestManager()

    def __str__(self):
        if hasattr(self, 'grant'):
            return f'Request:  {self.Citizen.Email}, {self.PublicService.Title}, {self.Message[:20]}, Grant:: {self.grant.granted}'
        else:
            return f'Request:  {self.Citizen.Email}, {self.PublicService.Title}, {self.Message[:20]}, Grant:: N/A'

from rest_framework.serializers import SlugRelatedField
from rest_framework.exceptions import APIException
from core.abstract.serializers import AbstractModelSerializer
from core.citizen.models import Citizen
from core.citizen.serializers import RequestCitizenSerializer
from core.publicService.models import PublicService
from core.publicService.serializers import RequestPublicServiceSerializer
from .models import Request

class CitizenRequestSerializer(AbstractModelSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')
    PublicService = SlugRelatedField(queryset=PublicService.objects.all(), slug_field='PublicId')

    def to_representation(self, instance:Request):
        data = super().to_representation(instance)
        try:
            data['Citizen'] = RequestCitizenSerializer(instance.Citizen).data
            data['PublicService'] = RequestPublicServiceSerializer(instance.PublicService).data
            if hasattr(instance, 'grant'):
                data['Granted'] = instance.grant.granted
                return data
            else:
                raise Exception()
        except:
            raise APIException('Failed to produce data')

    class Meta:
        model : Request = Request
        fields : list[str] = [
            'id', 'Subject', 'Message', 'Citizen', 'PublicService', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Created', 'Updated'
        ]

class GranteeRequestSerializer(CitizenRequestSerializer):
    class Meta:
        model : Request = Request
        fields : list[str] = [
            'id', 'Subject', 'Message', 'Citizen', 'PublicService', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Subject', 'Message', 'Citizen', 'PublicService', 'Created', 'Updated'
        ]

class AdministratorRequestSerializer(GranteeRequestSerializer):
    pass

class SiteManagerRequestSerializer(AdministratorRequestSerializer):

    pass

class GrantRequestSerializer(AbstractModelSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')
    PublicService = SlugRelatedField(queryset=PublicService.objects.all(), slug_field='PublicId')

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data["Citizen"] = instance.Citizen.UserName
        data['PublicService'] = instance.PublicService.Title
        return data

    class Meta:
        model : Request = Request
        fields : list[str] = [
            'id', 'Subject', 'Citizen', 'PublicService'
        ]
        read_only_fields : list[str] = [
            'id', 'Subject', 'Citizen', 'PublicService'
        ]

from django.shortcuts import render
from django.db.transaction import atomic
from rest_framework.exceptions import MethodNotAllowed
from core.abstract.viewset import AbstractModelViewSet, AbstractGranteeModelViewSet, AbstractAdministratorModelViewSet, AbstractSiteManagerModelViewSet
from core.department.models import Department
from core.association.models import Association
from .serializers import CitizenRequestSerializer, GranteeRequestSerializer, AdministratorRequestSerializer, SiteManagerRequestSerializer
# Create your views here.

class CitizenRequestViewSet(AbstractModelViewSet):
    serializer_class = CitizenRequestSerializer
    http_method_names = ('get', 'post', 'patch')

    def get_queryset(self):
        queries = self.get_queries()
        queries['Citizen'] = self.request.user
        return self.serializer_class.Meta.model.objects.filter(**queries)
    @atomic
    def create(self, request, *args, **kwargs):
        request.data['Citizen'] = self.request.user.PublicId.hex
        return super().create(request, *args, **kwargs)

class GranteeRequestViewSet(AbstractGranteeModelViewSet):
    serializer_class = GranteeRequestSerializer
    http_method_names = ('get')

    def get_queryset(self):
        if hasattr(self.request.user, 'grantee'):
            queries = self.get_queries()
            queries['PublicService__Grantee'] = self.request.user.grantee
            return self.serializer_class.Meta.model.objects.filter(**queries)
        else:
            raise MethodNotAllowed()

class AdministratorRequestViewSet(AbstractAdministratorModelViewSet):
    serializer_class = AdministratorRequestSerializer
    http_method_names = ('get')

    def get_queryset(self):
        if hasattr(self.request.user, 'administrator'):
            department = Department.objects.get(Administrator=self.request.user.administrator)
            associations = Association.objects.filter(Department=department)
            queries = self.get_queries()
            queries['PublicService__Association__in'] = associations
            return self.serializer_class.Meta.model.objects.filter(**queries)
        raise MethodNotAllowed()

class SiteManagerRequestViewSet(AbstractSiteManagerModelViewSet):
    serializer_class = SiteManagerRequestSerializer
    http_method_names = ('get')

from django.apps import AppConfig


class ServicepermissionsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.servicePermissions'
    label = 'servicePermissions'

from django.db import models
from core.abstract_circular.models import AbstractPermission
from datetime import datetime

# Create your models here.
class PublicServicePermission(AbstractPermission):
    PublicService = models.ForeignKey(to='publicService.PublicService', on_delete=models.CASCADE)

    def __str__(self):
        return f'PublicServicePermission: \n\tService:{self.PublicService.Title}, {super().__str__()}'

class AssociationPermission(AbstractPermission):
    Association = models.ForeignKey(to='association.Association', on_delete=models.CASCADE)

    def __str__(self):
        return f'AssociationPermission: \n\tAssocation: {self.Association.Title}, {super().__str__()}'
    
class DepartmentPermission(AbstractPermission):
    Department  = models.ForeignKey(to='department.Department', on_delete=models.CASCADE)

    def __str__(self):
        return f'DepartmentPermission: \n\tDepartment: {self.Department.Title}, {super().__str__()}'

from rest_framework.serializers import SlugRelatedField, SerializerMethodField
from core.abstract_circular.serializers import AbstractPermissionSerializer
from core.publicService.models import PublicService
from core.publicService.serializers import PermissionPublicServiceSerializer
from core.association.models import Association
from core.association.serializers import PermissionAssociationSerializer
from core.department.models import Department
from core.department.serializers import PermissionDepartmentSerializer
from .models import PublicServicePermission, AssociationPermission, DepartmentPermission

class PublicServicePermissionSerializer(AbstractPermissionSerializer):
    PublicService = SlugRelatedField(queryset=PublicService.objects.all(), slug_field='PublicId')

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['PublicService'] = PermissionPublicServiceSerializer(instance.PublicService).data
        return data
    
    class Meta:
        model : PublicServicePermission = PublicServicePermission
        fields : list[str] = [
            'id','Name', 'PermissionOpen', 'PublicService', 'Description' ,'StartTime', 'EndTime', 'Citizens', 'Created', 'Updated'
        ]
class AssociationPermissionSerializer(AbstractPermissionSerializer):
    Association = SlugRelatedField(queryset=Association.objects.all(), slug_field='PublicId')

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Association'] = PermissionAssociationSerializer(instance.Association).data
        return data
    
    class Meta:
        model : AssociationPermission = AssociationPermission
        fields : list[str] = [
            'id','Name', 'PermissionOpen', 'Association', 'Description' ,'StartTime', 'EndTime', 'Citizens', 'Created', 'Updated'
        ]

class DepartmentPermissionSerializer(AbstractPermissionSerializer):
    Department = SlugRelatedField(queryset=Department.objects.all(), slug_field='PublicId')

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Department'] = PermissionDepartmentSerializer(instance.Department).data
        return data

    class Meta:
        model : DepartmentPermission = DepartmentPermission
        fields : list[str] = [
            'id','Name', 'PermissionOpen', 'Department', 'Description' ,'StartTime', 'EndTime', 'Citizens', 'Created', 'Updated'
        ]

from django.shortcuts import render
from rest_framework.exceptions import MethodNotAllowed, ValidationError
from core.abstract.viewset import AbstractSiteManagerModelViewSet, AbstractAdministratorModelViewSet, AbstractGranteeModelViewSet
from core.association.models import Association
from core.publicService.models import PublicService
from core.department.models import Department
from core.grantee.models import Grantee
from .serializer import PublicServicePermissionSerializer, AssociationPermissionSerializer, DepartmentPermissionSerializer

# Create your views here.
class SiteManagerPublicServicePermissionViewSet(AbstractSiteManagerModelViewSet):
    http_method_names = ('get', 'patch', 'delete', 'post')
    serializer_class = PublicServicePermissionSerializer
    

class SiteManagerAssociationPermissionViewSet(AbstractSiteManagerModelViewSet):
    http_method_names = ('get', 'patch', 'delete', 'post')
    serializer_class = AssociationPermissionSerializer
    

class SiteManagerDepartmentPermissionViewSet(AbstractSiteManagerModelViewSet):
    http_method_names = ('get', 'patch', 'delete', 'post')
    serializer_class = DepartmentPermissionSerializer
    

class GranteePublicServicePermissionViewSet(AbstractGranteeModelViewSet):
    http_method_names = ('get', 'patch', 'delete', 'post')
    serializer_class = PublicServicePermissionSerializer
    
    def get_queryset(self):
        grantee : Grantee = self.request.user.grantee
        publicServices = PublicService.objects.filter(Grantee=grantee)
        queries = self.get_queries()
        queries['PublicService__in'] = publicServices
        return self.serializer_class.Meta.model.objects.filter(**queries)
    
    
    def create(self, request, *args, **kwargs):
        grantee = self.request.user.grantee
        publicServiceId = request.data.pop('PublicService', None)
        if publicServiceId == None:
            raise ValidationError('Invalid Service')
        if hasattr(grantee, 'association'):
            try:
                publicSrvc =PublicService.objects.filter(Grantee=grantee).get(PublicId=publicServiceId)
                request.data['PublicService'] = publicSrvc.PublicId.hex
            except:
                raise ValidationError('Invalid Service')

            return super().create(request, *args, **kwargs)
        raise ValidationError('You Do Not Belong to any Association')

class AdministratorPublicServicePermissionViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('get', 'patch', 'delete', 'post')
    serializer_class = PublicServicePermissionSerializer
    
    def get_queryset(self):
        administrator = self.request.user.administrator
        if hasattr(administrator, 'department'):
            associations = Association.objects.filter(Department=administrator.department)
            publicServices = PublicService.objects.filter(Association__in=associations)
            queries = self.get_queries()
            queries['PublicService__in'] = publicServices
            return self.serializer_class.Meta.model.objects.filter(**queries)
        raise MethodNotAllowed()
    
    def create(self, request, *args, **kwargs):
        administrator = self.request.user.administrator
        publicServiceId = request.data.pop('PublicService', None)
        if publicServiceId == None:
            raise ValidationError('Invalid Service')
        if hasattr(administrator, 'department'):
            try:
                associations = Association.objects.filter(Department=administrator.department)
                publicSrvc =PublicService.objects.filter(Association__in=associations).get(PublicId=publicServiceId)
                request.data['PublicService'] = publicSrvc.PublicId.hex
            except:
                raise ValidationError('Invalid Service')

            return super().create(request, *args, **kwargs)
        raise MethodNotAllowed('You Do Not Belong to Any Department')


class AdministratorAssociationPermissionViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('get', 'patch', 'delete', 'post')
    serializer_class = AssociationPermissionSerializer
    
    def get_queryset(self):
        administrator = self.request.user.administrator
        if hasattr(administrator, 'department'):
            associations = Association.objects.filter(Department=administrator.department)
            queries = self.get_queries()
            queries['Association__in'] = associations
            return self.serializer_class.Meta.model.objects.filter(**queries)
        raise MethodNotAllowed('You Do Not Belong to Any Department')
    
    def create(self, request, *args, **kwargs):
        administrator = self.request.user.administrator
        associationId = request.data.pop('Association', None)
        if associationId == None:
            raise ValidationError('Invalid Association')
        if hasattr(administrator, 'department'):
            try:
                association = Association.objects.filter(Department=administrator.department).get(PublicId=associationId)
                request.data['Association'] = association.PublicId.hex
            except:
                raise ValidationError('Invalid Association')

            return super().create(request, *args, **kwargs)
        raise MethodNotAllowed('You Do Not Belong to Any Department')

class AdministratorDepartmentPermissionViewSet(AbstractAdministratorModelViewSet):
    http_method_names = ('get', 'patch', 'delete', 'post')
    serializer_class = DepartmentPermissionSerializer

    def get_queryset(self):
        administrator = self.request.user.administrator
        if hasattr(administrator, 'department'):
            queries = self.get_queries()
            queries['Department'] = administrator.department
            return self.serializer_class.Meta.model.objects.filter(**queries)
        raise MethodNotAllowed('You Do Not Belong to Any Department')
    
    def create(self, request, *args, **kwargs):
        administrator = self.request.user.administrator
        if hasattr(administrator, 'department'):
            request.data['Department'] = administrator.department.PublicId.hex
            return super().create(request, *args, **kwargs)
        raise MethodNotAllowed('You Do Not Belong to Any Department')
from django.apps import AppConfig


class ServicesessionConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.serviceSession'
    label = 'serviceSession'

from django.db import models
from django.conf import settings
from django.utils import timezone
from core.abstract.models import AbstractModel, AbstractManager

# Create your models here.
class ServiceSessionManager(AbstractManager):

    def create(self, **kwargs):
        kwargs['LastSeen'] = timezone.now()
        return super().create(**kwargs)

    pass

class ServiceSession(AbstractModel):
    Citizen = models.ForeignKey(to='citizen.Citizen', on_delete=models.PROTECT)
    Service = models.ForeignKey(to='publicService.PublicService', on_delete=models.DO_NOTHING)
    IpAddress = models.CharField(max_length=19)
    LastSeen = models.DateTimeField(null=True)
    EnforceExpiry = models.BooleanField(default=False)

    objects : ServiceSessionManager = ServiceSessionManager()

    @property
    def expired(self):
        try:
            sessionHours: int = getattr(settings, "DEFAULT_SESSION_TIME", None)

            if self.EnforceExpiry:
                return True
            if sessionHours is None:
                return False
            
            expiration_time = self.LastSeen + timezone.timedelta(hours=sessionHours)
            return timezone.now() > expiration_time
        except:
            return True

from rest_framework import serializers
from core.abstract.serializers import AbstractModelSerializer
from core.citizen.models import Citizen as CitizenModel
from core.publicService.models import PublicService
from core.citizen.serializers import ServiceSessionCitizenSerializer
from core.publicService.serializers import ServiceSessionPublicServiceSerializer
from .models import ServiceSession

class GranteeServiceSessionSerializer(AbstractModelSerializer):

    Citizen = serializers.SlugRelatedField(queryset=CitizenModel.objects.all(), slug_field="PublicId")
    Service = serializers.SlugRelatedField(queryset=PublicService.objects.all(), slug_field="PublicId")
    Expired = serializers.SerializerMethodField()

    def get_Expired(self, serviceSession : ServiceSession) -> bool:
        return serviceSession.expired

    def to_representation(self, instance) -> dict:
        data = super().to_representation(instance)
        data['Citizen'] = ServiceSessionCitizenSerializer(instance.Citizen).data
        data['Service'] = ServiceSessionPublicServiceSerializer(instance.Service).data
        return data
    class Meta:
        model : ServiceSession = ServiceSession
        fields : list[str] = [
            'id', 'Citizen', 'Service', "IpAddress", 'EnforceExpiry', 'LastSeen', 'Expired', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Citizen', 'Service', "IpAddress", 'EnforceExpiry', 'LastSeen', 'Expired', 'Created', 'Updated'
        ]

class AdministratorServiceSessionSerializer(GranteeServiceSessionSerializer):

    class Meta:
        model : ServiceSession = ServiceSession
        fields : list[str] = [
            'id', 'Citizen', 'Service', "IpAddress", 'EnforceExpiry', 'LastSeen', 'Expired', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Citizen', 'Service', "IpAddress", 'EnforceExpiry', 'LastSeen', 'Expired', 'Created', 'Updated'
        ]

class SiteManagerServiceSessionSerializer(GranteeServiceSessionSerializer):

    class Meta:
        model : ServiceSession = ServiceSession
        fields : list[str] = [
            'id', 'Citizen', 'Service', "IpAddress", 'EnforceExpiry', 'LastSeen', 'Expired', 'Created', 'Updated'
        ]
        read_only_fields : list[str] = [
            'id', 'Created', 'Expired', 'Updated'
        ]

from django.shortcuts import render
from core.abstract.viewset import AbstractAdministratorModelViewSet, AbstractGranteeModelViewSet, AbstractSiteManagerModelViewSet
from .serializers import SiteManagerServiceSessionSerializer, AdministratorServiceSessionSerializer, GranteeServiceSessionSerializer
from datetime import datetime, timezone
from django.utils import timezone as djTimezone


# Create your views here.
class GranteeServiceSessionViewSet(AbstractGranteeModelViewSet):
    serializer_class = GranteeServiceSessionSerializer
    http_method_names = ('get')


class AdministratorServiceSessionViewSet(AbstractAdministratorModelViewSet):
    serializer_class = AdministratorServiceSessionSerializer
    http_method_names = ('get')

class SiteManagerServiceSessionViewSet(AbstractSiteManagerModelViewSet):
    serializer_class = SiteManagerServiceSessionSerializer
    http_method_names = ('get', 'post', 'patch')

    def update(self, request, *args, **kwargs):
        dt = djTimezone.now()
        formatted = dt.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        if request.data == {}:
            request.data["LastSeen"] =  formatted
        elif hasattr(request.data , "LastSeen"):
            outcome = request.data.pop("LastSeen")
        return super().update(request, *args, **kwargs)

from django.apps import AppConfig


class SitemanagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.siteManager'
    label = 'siteManager'
from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from core.abstract.models import AbstractManager, AbstractModel
from rest_framework.exceptions import PermissionDenied

# Create your models here.
class SiteManagerManager(BaseUserManager, AbstractManager):

    def create(self, **kwargs):
        if self.all().count() > 0:
            raise PermissionDenied('There Should Only Be One Site Manager.')
        return super().create(**kwargs)
    pass

class SiteManager(AbstractBaseUser, AbstractModel):
    ManagerUserName = models.CharField(unique=True, max_length=100)
    Citizen = models.OneToOneField(to='citizen.Citizen', on_delete=models.PROTECT)
    FirstEmail = models.EmailField(unique=True)
    SecondEmail = models.EmailField(unique=True, null=True)

    objects : SiteManagerManager = SiteManagerManager()
    USERNAME_FIELD = 'FirstEmail'
    REQUIRED_FIELDS = ['ManagerUserName']

    def __str__(self):
        return f'Site Manager Account: {self.ManagerUserName}, {self.FirstEmail}, {self.SecondEmail}'

from core.abstract.serializers import AbstractModelSerializer
from core.siteManager.models import SiteManager
from core.citizen.serializers import StaffCitizenSerializer

class SiteManagerSerializer(AbstractModelSerializer):

    def to_representation(self, instance):
        data = super().to_representation(instance)
        data['Citizen'] = StaffCitizenSerializer(instance.Citizen).data
        return data

    class Meta:
        model : SiteManager = SiteManager
        fields = [
            'id', 'ManagerUserName', 'Citizen', 'FirstEmail', 'SecondEmail', 'Created', 'Updated'
        ]
        read_only_fields = [
            'id', 'ManagerUserName', 'Citizen', 'FirstEmail', 'SecondEmail', 'Created', 'Updated'
        ]
from django.shortcuts import render
from rest_framework.permissions import IsAuthenticated
from core.abstract.viewset import AbstractSiteManagerModelViewSet
from .serializers import SiteManagerSerializer



# Create your views here.
class SiteManagerModelViewSet(AbstractSiteManagerModelViewSet):
    http_method_names = ('get', 'patch',)
    serializer_class = SiteManagerSerializer
    permission_classes = (IsAuthenticated,)

    def get_object(self):
        return self.request.user.sitemanager

    def get_queryset(self):
        return self.serializer_class.Meta.model.objects.all()


from django.apps import AppConfig


class SystemlogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core.systemLog'
    label = 'systemLog'
from django.db import models
from core.abstract_circular.models import AbstractLogModel, AbstractLogManager

# Create your models here.
class CitizenLogManager(AbstractLogManager):

    pass 

class CitizenLog(AbstractLogModel):
    
    objects : CitizenLogManager = CitizenLogManager()

    def __str__(self):
        return f'LOG:: \n\tCitizen: {self.Citizen.UserName}, \n\tObject: {self.Object} \n\tMethod: {self.Method}'
class GranteeLogManager(AbstractLogManager):
    pass
class GranteeLog(AbstractLogModel):
    Grantee = models.CharField()

    objects : GranteeLogManager = GranteeLogManager()

    def __str__(self):
        return f'LOG:: \n\tCitizen: {self.Citizen} \n\tGrantee: {self.Grantee.GranteeUserName}, \n\tObject: {self.Object} \n\tMethod: {self.Method}'

class AdministratorLogManager(AbstractLogManager):

    pass

class AdministratorLog(AbstractLogModel):
    Administrator = models.CharField()
    
    objects : AdministratorLogManager = AdministratorLogManager()

    def __str__(self):
        return f'LOG:: \n\tCitizen: {self.Citizen.UserName} \n\tAdministrator: {self.Administrator}, \n\tObject: {self.Object} \n\tMethod: {self.Method}'


class SiteManagerLogManager(AbstractLogManager):

    pass
class SiteManagerLog(AbstractLogModel):
    SiteManager  = models.CharField()
    objects : SiteManagerLogManager = SiteManagerLogManager()

    def __str__(self):
        return f'LOG:: \n\tCitizen: {self.Citizen.UserName} \n\tManager: {self.SiteManager}, \n\tObject: {self.Object} \n\tMethod: {self.Method}'
from rest_framework.serializers import SlugRelatedField
from core.siteManager.models import SiteManager
from core.administrator.models import Administrator
from core.citizen.models import Citizen
from core.grantee.models import Grantee
from core.abstract_circular.serializers import AbstractLogSerializer
from .models import CitizenLog, GranteeLog, AdministratorLog, SiteManagerLog


class SiteManagerLogSerializer(AbstractLogSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')
    
    class Meta:
        model : SiteManagerLog = SiteManagerLog
        fields : list[str] = [
            'id','Citizen', 'IpAddress', 'SiteManager', 'Method', 'Object', 'RecordId', 'Message', 'Created', 'Updated'

        ]

class AdministratorLogSerializer(AbstractLogSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')

    class Meta:
        model : AdministratorLog = AdministratorLog
        fields : list[str] = [
            'id','Citizen', 'IpAddress', 'Administrator', 'Method', 'Object', 'RecordId', 'Message', 'Created', 'Updated'

        ]

class GranteeLogSerializer(AbstractLogSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')

    class Meta:
        model : GranteeLog = GranteeLog
        fields : list[str] = [
            'id','Citizen', 'IpAddress', 'Grantee', 'Method', 'Object', 'RecordId', 'Message', 'Created', 'Updated'

        ]

class CitizenLogSerializer(AbstractLogSerializer):
    Citizen = SlugRelatedField(queryset=Citizen.objects.all(), slug_field='PublicId')

    class Meta:
        model : CitizenLog = CitizenLog
        fields : list[str] = [
            'id','Citizen', 'IpAddress', 'Method', 'Object', 'RecordId', 'Message', 'Created', 'Updated'

        ]
from core.systemCron.models import SystemCron, systemLog
from rest_framework.status import HTTP_201_CREATED
from core.systemLog.serializers import CitizenLogSerializer, SiteManagerLogSerializer, AdministratorLogSerializer, GranteeLogSerializer
from core.abstract_circular.serializers import AbstractLogSerializer
from core.abstract.kafka import NewKafkaConsumer
from core.abstract_circular.viewsets import AdministratorLogViewSet, SiteManagerLogViewSet, GranteeLogViewSet
from .serializers import CitizenLogSerializer, GranteeLogSerializer, AdministratorLogSerializer, SiteManagerLogSerializer
from pprint import pprint
from django.utils import timezone
from threading import Thread
from django.conf import settings
from rest_framework.response import Response
import logging
import json

logger = logging.getLogger(__name__)

# Create your views here.
class GranteeCitizenLogViewSet(GranteeLogViewSet):
    serializer_class = CitizenLogSerializer

class AdministratorCitizenLogViewSet(AdministratorLogViewSet):
    serializer_class = CitizenLogSerializer

class AdministratorGranteeLogViewSet(AdministratorLogViewSet):
    serializer_class = GranteeLogSerializer

class SiteManagerCitizenLogViewSet(SiteManagerLogViewSet):
    serializer_class = CitizenLogSerializer

class SiteManagerGranteeLogViewSet(SiteManagerLogViewSet):
    serializer_class = GranteeLogSerializer

class SiteManagerAdministratorLogViewSet(SiteManagerLogViewSet):
    serializer_class = AdministratorLogSerializer

class SiteManagerManagerLogViewSet(SiteManagerLogViewSet):
    http_method_names = ('post', 'get')
    serializer_class = SiteManagerLogSerializer

    def createLog(self, data:dict, serializer_class: AbstractLogSerializer):
        try:
            serializer : AbstractLogSerializer = serializer_class(data=data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
            return serializer.data
        except Exception as e:
            return False

    def create(self, request, *args, **kwargs):
        data: dict = request.data
        administrator = data.pop('Administrator', None)
        siteManager = data.pop('SiteManager', None)
        grantee = data.pop('SiteManager', None)
        if (administrator != None ):
            data['Administrator'] = administrator
            outcome  = self.createLog(data, AdministratorLogSerializer)
        if (siteManager != None ):
            data['SiteManager'] = siteManager
            outcome = self.createLog(data, SiteManagerLogSerializer)
        if (grantee != None ):
            data['Grantee'] = grantee
            outcome = self.createLog(data, GranteeLogSerializer)
        else:
            outcome = self.createLog(data, CitizenLogSerializer)
        return Response(outcome, HTTP_201_CREATED)


package verify

import (
	"fmt"
	"net"
	"net/http"
	"strings"
)

var (
	available_methods = []string{"get", "patch", "delete", "post"}
)

func VerifyMethods(methods []string) error {
	for _, value := range methods {
		found := false
		for _, fixed_value := range available_methods {
			if strings.ToLower(value) == strings.ToLower(fixed_value) {
				found = true
			}
		}
		if !found {
			return fmt.Errorf("invalid method")
		}
	}
	return nil
}

// func VerifyMachineNames(endpoints map[string]*types.Endpoint) error {
// 	for key, endpoint := range endpoints {
// 		for secondKey, duplicate := range endpoints {
// 			if key != secondKey {
// 				if strings.ToLower(endpoint.MachineName) == strings.ToLower(duplicate.MachineName) {
// 					return fmt.Errorf("duplicate services")
// 				}
// 			}
// 		}
// 	}
// 	return nil
// }

func GetIP(r *http.Request) string {
	// Check for X-Forwarded-For header first (standard for proxies)
	ip := r.Header.Get("X-Forwarded-For")
	if ip != "" {
		// X-Forwarded-For can contain multiple IPs (client, proxy1, proxy2, ...)
		// The first one is the original client IP
		ips := strings.Split(ip, ",")
		if len(ips) > 0 {
			return strings.TrimSpace(ips[0])
		}
	}

	// Try other common headers
	ip = r.Header.Get("X-Real-IP")
	if ip != "" {
		return ip
	}

	// Try X-Client-IP (used by some CDNs and proxies)
	ip = r.Header.Get("X-Client-IP")
	if ip != "" {
		return ip
	}

	// Use RemoteAddr as fallback
	if r.RemoteAddr != "" {
		// RemoteAddr includes port, so we need to strip it
		ipWithPort := r.RemoteAddr
		host, _, err := net.SplitHostPort(ipWithPort)
		if err == nil {
			return host
		}
		// If SplitHostPort fails, return the original string
		return ipWithPort
	}

	return "unknown"
}

func NormalizeIP(ipStr string) string {
	ip := net.ParseIP(ipStr)
	if ip == nil {
		return ipStr // Invalid IP, return as-is
	}

	// Convert IPv6 loopback (::1) to IPv4 loopback
	if ip.IsLoopback() && ip.To4() == nil {
		return "127.0.0.1"
	}

	// Convert IPv6-mapped IPv4 (::ffff:x.x.x.x) to x.x.x.x
	if ip4 := ip.To4(); ip4 != nil {
		return ip4.String()
	}

	// Return the normalized IPv6 string
	return ip.String()
}

package types

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"net/http/httputil"
	"strings"
)

type Authenticator struct {
	Request            *http.Request
	ResponseWriter     http.ResponseWriter
	Code               *int
	Service            string
	ServiceMachineName string
	ServiceId          string
	SystemLog          SystemLogInterface
	Endpoints          *MapEndPoint
	Proxy              *httputil.ReverseProxy
}

func (auth *Authenticator) PopulateAuthenticate(endpoints *MapEndPoint, managerCredentials *ManagerLogInCredentials) error {
	auth.Endpoints = endpoints
	err := auth.UrlData(endpoints)
	if err != nil {
		return err
	}
	serviceDetails := map[string]string{"service": auth.ServiceMachineName, "serviceId": auth.ServiceId}
	return auth.SystemLog.Populate(auth.Request, serviceDetails, managerCredentials)
}

func (auth *Authenticator) VerifyService() error {
	return nil
}

func (auth *Authenticator) UrlData(endpoints *MapEndPoint) error {
	auth.ServiceMachineName = auth.GetServiceName(auth.Request.URL.Path)
	auth.Service = auth.GetServiceName(auth.Request.URL.Path)
	path := auth.Request.URL.Path
	log.Println(path)
	endPoint, exists := endpoints.GetEndPoint(auth.Service)
	if !exists {
		data := map[string]string{"message": "Service Not Found"}
		auth.ResponseWriter.WriteHeader(http.StatusNotFound)
		json.NewEncoder(auth.ResponseWriter).Encode(data)
		return fmt.Errorf("service not found")
	}
	auth.ServiceId = endPoint.ServiceId
	auth.Request.URL.Path = strings.Replace(path, auth.ServiceMachineName, "/"+endPoint.FixedPath+"/", 1)
	auth.Request.URL.Path = RefineUrl(auth.Request.URL.Path)
	return nil
}
func (auth *Authenticator) GetServiceName(r string) string {
	parts := strings.FieldsFunc(r, func(rw rune) bool {
		return rw == '/'
	})
	log.Println("service accessed", parts[0])
	return parts[0]
}

//	func NewAuthenticator(w http.ResponseWriter, r *http.Request) *Authenticator {
//		return &Authenticator{
//			Request:        r,
//			ResponseWriter: w,
//			SystemLog:      &SystemLog{},
//		}
//	}
func NewAuthenticator(r *http.Request) *Authenticator {
	return &Authenticator{
		Request:   r,
		SystemLog: &SystemLog{},
	}
}


package types

import (
	"net/http"
	"net/url"
)

type HandlerFunc func(http.ResponseWriter, *http.Request)

type HandleServeInterface interface {
	Serve(interface{})
}

type Endpoint struct {
	ServiceName string
	MachineName string
	URL         *url.URL
	FixedPath   string
	Methods     []string
	ServiceId   string
}
type MapEndPoint map[string]*Endpoint

func (m MapEndPoint) GetEndPoint(name string) (*Endpoint, bool) {
	endPoint, exists := m[name]
	return endPoint, exists
}

type AssociationClient struct {
	Endpoints []Endpoint `json:"endpoints"`
	Service   string     `json:"company"`
	Type      string     `json:"http"`
}

type RequestData struct {
	Model    string
	Method   string
	UserType string
	URL      *url.URL
}

package types

var (
	GatewayDomain                = "http://127.0.0.1:8020/"
	CentralDomain                = "http://127.0.0.1:8000/api/"
	LoginEndpoint                = CentralDomain + "manager/login/"
	RefreshEndpoint              = CentralDomain + "auth/refresh/"
	rudiUrl                      = "http://127.0.0.1:8002"
	rudiUrl2                     = "http://127.0.0.1:8001"
	Central_access_managementUrl = "http://127.0.0.1:8000/api"
	Exempt_models                = []string{"login", "refresh"}
	Base_models                  = []string{"manager", "grantee", "admin", "permission", "log", "auth"}
	SecondLevel_base_models      = []string{"permission", "log"}
	KafkaLoggerTopic             = "systemLog"
)

func RefineUrl(url string) string {
	prev := ""
	newString := ""
	for key, str := range url {
		if key == 0 {
			prev = string(str)
			newString = newString + prev
			continue
		}
		if prev == "/" && string(str) == "/" {
			continue
		}
		newString = newString + string(str)
		prev = string(str)

	}
	return newString
}


package types

import (
	"bytes"
	"encoding/json"
	"io"
	"log"
	"net/http"
	"time"
)

type ManagerLogInCredentials struct {
	Email           string `json:"Email"`
	Password        string `json:"password"`
	ManagerUserName string `json:"ManagerUserName"`
	ManagerPassword string `json:"ManagerPassword"`
	Access          string `json:"access"`
	Refresh         string `json:"refresh"`
}

func (c *ManagerLogInCredentials) login() {
	credentials, err := json.Marshal(c)
	if err != nil {
		log.Fatal("Credentials json error")
	}
	req, err := http.NewRequest("POST", LoginEndpoint, bytes.NewBuffer(credentials))
	if err != nil {
		log.Fatal("Creation: http login Request")
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal("http login request failed")
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		bodyBytes, err := io.ReadAll(resp.Body)
		if err != nil {
			log.Fatal("http server response failed, \n: body conversion failed as well")
		}
		log.Fatal("http server response failed:\n\tBody: \t" + string(bodyBytes))
	}

	var respContainer ManagerLogInCredentials
	if err := json.NewDecoder(resp.Body).Decode(&respContainer); err != nil {
		log.Fatal("Credentials Decoding failed", err)
	}
	c.Access = respContainer.Access
	c.Refresh = respContainer.Refresh
}

func (c *ManagerLogInCredentials) refresh() bool {
	credentials, err := json.Marshal(c)
	if err != nil {
		log.Fatal("Refresh:: Credentials json error")
	}
	req, err := http.NewRequest("POST", RefreshEndpoint, bytes.NewBuffer(credentials))
	if err != nil {
		log.Fatal("Creation: http refresh Request")
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal("http refresh request failed")
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusUnauthorized {
		return false
	}

	if resp.StatusCode != http.StatusOK {
		bodyBytes, err := io.ReadAll(resp.Body)
		if err != nil {
			log.Fatal("Refresh: http server response failed, \n: body conversion failed as well")
		}
		log.Fatal("Refresh: http server response failed:\n\tBody: \t" + string(bodyBytes))
	}

	var respContainer ManagerLogInCredentials
	if err := json.NewDecoder(resp.Body).Decode(&respContainer); err != nil {
		log.Fatal("Refresh: Credentials Decoding failed", err)
	}
	c.Access = respContainer.Access
	return true
}

func (c *ManagerLogInCredentials) StartCredentials() {
	c.login()
	go func() {
		for {
			success := c.refresh()
			if !success {
				c.login()
			}
			time.Sleep(time.Minute * 4)
		}
	}()

}


package types

// import (
// 	"encoding/json"
// 	"fmt"
// 	"log"

// 	"github.com/confluentinc/confluent-kafka-go/v2/kafka"
// )

// type Logger struct {
// 	Producer *kafka.Producer
// 	Topic    string
// 	next     HandleServeInterface
// }

// func (logger *Logger) Serve(auth *Authenticator) {
// 	logger.next.Serve(auth)
// 	logger.LogData(auth)
// }

// func (logger *Logger) LogData(auth *Authenticator) error {
// 	jsonLog, err := json.Marshal(auth.SystemLog)
// 	if err != nil {
// 		return fmt.Errorf("Failed to marshal log data")
// 	}
// 	err = logger.Producer.Produce(
// 		&kafka.Message{
// 			TopicPartition: kafka.TopicPartition{Topic: &logger.Topic, Partition: kafka.PartitionAny},
// 			Value:          jsonLog},
// 		nil,
// 	)
// 	if err != nil {
// 		return fmt.Errorf("Failed to push data to kafka")
// 	}
// 	return nil

// }

// func NewLoggerKafkaProducer(prevServer HandleServeInterface) (*Logger, error) {
// 	producer, err := kafka.NewProducer(&kafka.ConfigMap{
// 		"bootstrap.servers": "host1:9092, host2:9092",
// 		"client.id":         "central-access-gateway",
// 		"acks":              "all",
// 	})
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to create the producer: %s", err.Error())
// 	}
// 	go func() {
// 		for e := range producer.Events() {
// 			switch ev := e.(type) {
// 			case *kafka.Message:
// 				if ev.TopicPartition.Error != nil {
// 					log.Printf("Delivery failed: %v\n ", ev.TopicPartition)
// 				} else {
// 					log.Printf("Delivered message: to %v\n", ev.TopicPartition)
// 				}
// 			}
// 		}
// 	}()
// 	logger := Logger{
// 		Producer: producer,
// 		Topic:    KafkaLoggerTopic,
// 		next:     prevServer,
// 	}

// 	return &logger, nil

// }


package types

import (
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
)

type GlobalMetricsHolder struct {
	GlobalReqLatency      prometheus.Histogram
	GlobalErrLatency      prometheus.Histogram
	GlobalReqCounter      prometheus.Counter
	GlobalErrCounter      prometheus.Counter
	GlobalServicesCounter prometheus.Counter
}

func NewGlobalMetricsHolder() *GlobalMetricsHolder {

	globalReqLatency := promauto.NewHistogram(prometheus.HistogramOpts{
		Namespace: "global_request_latency",
		Name:      "global",
		Buckets:   []float64{0.1, 0.5, 1.0},
	})
	globalErrLatency := promauto.NewHistogram(prometheus.HistogramOpts{
		Namespace: "global_error_latency",
		Name:      "global",
		Buckets:   []float64{0.1, 0.5, 1.0},
	})
	globalReqCounter := promauto.NewCounter(prometheus.CounterOpts{
		Namespace: "global_request_counter",
		Name:      "global",
	})
	globalErrCounter := promauto.NewCounter(prometheus.CounterOpts{
		Namespace: "global_error_counter",
		Name:      "global",
	})
	globalServicesCounter := promauto.NewCounter(prometheus.CounterOpts{
		Namespace: "global_services_counter",
		Name:      "global",
	})

	return &GlobalMetricsHolder{
		GlobalReqLatency:      globalReqLatency,
		GlobalErrLatency:      globalErrLatency,
		GlobalReqCounter:      globalReqCounter,
		GlobalErrCounter:      globalErrCounter,
		GlobalServicesCounter: globalServicesCounter,
	}

}


package types

import (
	"fmt"
)

type PublicService struct {
	PublicId    string              `json:"id"`
	Title       string              `json:"Title"`
	MachineName string              `json:"MachineName"`
	Description string              `json:"Description"`
	Email       string              `json:"Email"`
	Grantee     []map[string]string `json:"Grantee"`
	Association map[string]string   `json:"Association"`
	Restricted  bool                `json:"Restricted"`
	URL         string              `json:"URL"`
	Visibility  bool                `json:"Visibility"`
	Methods     []string            `json:"Methods"`
}

func (s *PublicService) String() string {
	return fmt.Sprint(s.Title + ": \tMachine Name: " + s.MachineName + "\tUrl: " + s.URL)
}

type ServiceSessionService struct {
	PublicId    string `json:"id"`
	Title       string `json:"Title"`
	MachineName string `json:"MachineName"`
	URL         string `json:"URL"`
}

type ServiceSessionCitizen struct {
	PublicId   string `json:"id"`
	UserName   string `json:"UserName"`
	Email      string `json:"Email"`
	FirstName  string `json:"FirstName"`
	SecondName string `json:"SecondName"`
	NationalId string `json:"NationalId"`
}

type ServiceSession struct {
	PublicId      string                `json:"id"`
	Citizen       ServiceSessionCitizen `json:"Citizen"`
	Service       ServiceSessionService `json:"Service"`
	IpAddress     string                `json:"IpAddress"`
	EnforceExpiry bool                  `json:"EnforceExpiry"`
	Expired       bool                  `json:"Expired"`
}
type ServiceSessionRequest struct {
	Citizen   string `json:"Citizen"`
	Service   string `json:"Service"`
	IpAddress string `json:"IpAddress"`
}


package types

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/verify"
)

type SystemLogInterface interface {
	Populate(request *http.Request, service map[string]string, managerCredentials *ManagerLogInCredentials) error
	getCitizen(request *http.Request, managerCredentials *ManagerLogInCredentials) error
	CheckSessions(managerCredentials *ManagerLogInCredentials) error
	VerifyService(authenticationHeader string, managerCredentials *ManagerLogInCredentials) error
	getSpecialUserId(authenticationHeader string) error
	SetStatusCode(statusCode int)
	SetRecordId(id string)
	SetMessage(message string)
	SetObject(object string)
	GenerateLog() (SystemLogInterface, error)
	GetSpecialUser() string
}

type SystemLog struct {
	Citizen       string `json:"Citizen"`
	Method        string `json:"Method"`
	Object        string `json:"Object"`
	RecordId      string `json:"RecordId"`
	StatusCode    int    `json:"StatusCode"`
	Message       string `json:"Message"`
	IpAddress     string `json:"IpAddress"`
	SpecialUser   string
	SpecialUserId string
}

type AdministratorSystemLog struct {
	SystemLog
	Administrator string `json:"Administrator"`
}

type ManagerSystemLog struct {
	SystemLog
	SiteManager string `json:"SiteManager"`
}

type GranteeSystemLog struct {
	SystemLog
	Grantee string `json:"Grantee"`
}

func (sl *SystemLog) Populate(request *http.Request, service map[string]string, managerCredentials *ManagerLogInCredentials) error {
	sl.IpAddress = verify.NormalizeIP(verify.GetIP(request))
	parts := strings.FieldsFunc(request.URL.Path, func(rw rune) bool {
		return rw == '/'
	})
	var secondary bool = false
	var found = false
	var baseModel string
	sl.RecordId = "n/a"
	if service["service"] == "c_a_m" {
		for key, routeComponent := range parts {
			if !found {
				if answer, text := isBaseModel(routeComponent, secondary); !answer {
					if baseModel == "auth" || baseModel == "manager" || baseModel == "grantee" || baseModel == "admin" {
						sl.Object = Capitalize(text)
					} else {
						sl.Object = Capitalize(text) + Capitalize(baseModel)
					}
					if sl.Object == "Service" {
						sl.Object = "PublicService"
					}
					found = true
					if len(parts) == 1 {
						sl.SpecialUser = "citizen"
					}
					continue
				}
			} else {
				sl.RecordId = routeComponent
			}

			baseModel = routeComponent
			if (baseModel == "manager" || baseModel == "admin" || baseModel == "grantee" || baseModel == "auth") && key == 0 {
				if baseModel == "auth" {
					sl.SpecialUser = "citizen"
				} else {
					sl.SpecialUser = baseModel
				}
			} else {
				sl.SpecialUser = "citizen"
			}
			secondary = true
		}
		sl.Method = request.Method
		if sl.Method == http.MethodPost {
			sl.Message = "Created Entity"
		} else if sl.Method == http.MethodPatch {
			sl.RecordId = parts[len(parts)-1]
			sl.Message = "Edited Entity: " + sl.RecordId
		} else if sl.Method == http.MethodDelete {
			sl.RecordId = parts[len(parts)-1]
			sl.Message = "Deleted Entity: " + sl.RecordId
		} else {
			sl.Message = "Accessd Entity: N\\A"
		}
	} else {
		sl.SpecialUser = "citizen"
		sl.Object = "Service"
		sl.RecordId = service["serviceId"]
		sl.Method = request.Method
		sl.Message = "Accessed Service: " + service["service"]
	}

	if !isExemptModel(strings.ToLower(sl.Object)) {
		authenticationHeader := request.Header.Get("Authorization")
		if sl.Object == "Service" {
			if err := sl.CheckSessions(managerCredentials); err != nil {
				log.Println("There was an error:\n" + err.Error())
				err := sl.getCitizen(request, managerCredentials)
				if err != nil {
					log.Println(err)
					return err
				}
			}
		} else {
			err := sl.getCitizen(request, managerCredentials)
			if err != nil {
				log.Println(err)
				return err
			}
		}

		// if authenticationHeader == "" {
		// 	return fmt.Errorf("Not Authenticated")
		// }

		// fmt.Println(sl.Citizen)
		if sl.SpecialUser != "citizen" {
			if err := sl.getSpecialUserId(authenticationHeader); err != nil {
				log.Println("Failed To get special user")
				return err
			}
		}

	}
	fmt.Println("object: ", sl.Object)
	fmt.Println("Method: ", sl.Method)
	fmt.Println("User: ", sl.SpecialUser)
	fmt.Println("Id: ", sl.RecordId)
	fmt.Println("Citizen: ", sl.Citizen)
	return nil

}
func (sl *SystemLog) getCitizen(request *http.Request, managerCredentials *ManagerLogInCredentials) error {
	authenticationHeader := request.Header.Get("Authorization")

	req, err := http.NewRequest("GET", CentralDomain+"citizen/stuff/", nil)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", authenticationHeader)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("Authentication Failed")
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	var user User
	if err := json.Unmarshal(body, &user); err != nil {
		return err
	}
	sl.Citizen = user.PublicId
	if sl.Object == "Service" {
		return sl.VerifyService(authenticationHeader, managerCredentials)
	}
	return nil
}

func (sl *SystemLog) getSpecialUserId(authenticationHeader string) error {
	req, err := http.NewRequest("GET", CentralDomain+sl.SpecialUser+"/"+sl.SpecialUser+"/stuff", nil)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", authenticationHeader)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("authentication failed")
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	var user User
	if err := json.Unmarshal(body, &user); err != nil {
		return err
	}
	sl.SpecialUserId = user.PublicId
	return nil
}
func (sl *SystemLog) VerifyService(authenticationHeader string, managerCredentials *ManagerLogInCredentials) error {
	if sl.RecordId == "" {
		return fmt.Errorf("service error")
	}

	session := ServiceSessionRequest{
		Citizen:   sl.Citizen,
		Service:   sl.RecordId,
		IpAddress: sl.IpAddress,
	}
	fmt.Println(session)
	// fmt.Println("log: " + CentralDomain + "service/" + sl.RecordId)
	req, err := http.NewRequest("GET", CentralDomain+"service/"+sl.RecordId+"/", nil)
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", authenticationHeader)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusNotFound {
		return fmt.Errorf("service unauthorized")
	} else if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("authentication failed")
	}
	sessionJson, err := json.Marshal(session)
	if err != nil {
		return fmt.Errorf("Failed to create Session: 0")
	}
	sessionReq, err := http.NewRequest("POST", CentralDomain+"manager/session/", bytes.NewBuffer(sessionJson))
	if err != nil {
		return fmt.Errorf("Failed to create Session: 1")
	}
	sessionReq.Header.Set("Content-Type", "application/json")
	sessionReq.Header.Set("Authorization", "Bearer "+managerCredentials.Access)
	resp, err = http.DefaultClient.Do(sessionReq)
	if err != nil {
		log.Println("Failed To Create Session: 2")
		return fmt.Errorf("Failed To Create Session: 2")
	}
	defer resp.Body.Close()
	_, _ = io.Copy(io.Discard, resp.Body) // important!
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		log.Println("Failed To Create Session: 2 service unauthorised: " + managerCredentials.Access)
		return fmt.Errorf("service unauthorized")
	}
	return nil
}

func (sl *SystemLog) CheckSessions(managerCredentials *ManagerLogInCredentials) error {
	if sl.IpAddress == "unknown" || sl.IpAddress == "" {
		return fmt.Errorf("Authentication Failed")
	}
	fmt.Println("IpAddress: ", sl.IpAddress, "Service: "+sl.RecordId)
	sessionReq, err := http.NewRequest("GET", CentralDomain+"manager/session/?Service__PublicId="+sl.RecordId+"&IpAddress="+sl.IpAddress, nil)
	if err != nil {
		return fmt.Errorf("failed to get session: 1")
	}
	sessionReq.Header.Set("Content-Type", "application/json")
	sessionReq.Header.Set("Authorization", "Bearer "+managerCredentials.Access)
	resp, err := http.DefaultClient.Do(sessionReq)
	if err != nil {
		return fmt.Errorf("failed to get session: 2")
	}
	defer resp.Body.Close()
	// _, _ = io.Copy(io.Discard, resp.Body) // important!
	fmt.Println("Bearer: ", "Bearer "+managerCredentials.Access)
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("service unauthorized")
	}
	var respContainer []ServiceSession
	if err := json.NewDecoder(resp.Body).Decode(&respContainer); err != nil {
		log.Println("credentials decoding failed: check session", err)
		return fmt.Errorf("credentials decoding failed: check session")
	}
	found := false
	serviceSessionFound := ServiceSession{}
	for _, serviceSession := range respContainer {
		if serviceSession.Expired {
			continue
		}
		found = true
		serviceSessionFound = serviceSession
		break
	}
	if found {
		sl.Citizen = serviceSessionFound.Citizen.PublicId
		updateReq, err := http.NewRequest("PATCH", CentralDomain+"manager/session/"+serviceSessionFound.PublicId+"/", nil)
		if err != nil {
			return fmt.Errorf("failed to create update session request")
		}
		updateReq.Header.Set("Content-Type", "application/json")
		updateReq.Header.Set("Authorization", "Bearer "+managerCredentials.Access)
		updateResp, err := http.DefaultClient.Do(updateReq)
		if err != nil {
			return fmt.Errorf("failed to send update session request")
		}
		defer updateResp.Body.Close()
		if updateResp.StatusCode != http.StatusOK && updateResp.StatusCode != http.StatusCreated {
			return fmt.Errorf("failed to update session: server side")
		}
		return nil
	}
	return fmt.Errorf("failed to find active session")
}
func (sl *SystemLog) GenerateLog() (SystemLogInterface, error) {
	if sl.SpecialUser == "citizen" {
		return sl, nil
	} else if sl.SpecialUser == "manager" {
		return &ManagerSystemLog{
			SystemLog:   *sl,
			SiteManager: sl.SpecialUserId,
		}, nil
	} else if sl.SpecialUser == "admin" {
		return &AdministratorSystemLog{
			SystemLog:     *sl,
			Administrator: sl.SpecialUserId,
		}, nil
	} else if sl.SpecialUser == "grantee" {
		return &GranteeSystemLog{
			SystemLog: *sl,
			Grantee:   sl.SpecialUserId,
		}, nil
	}

	return nil, fmt.Errorf("specialUser not set")

}

func (sl *SystemLog) SetRecordId(id string) {
	sl.RecordId = id
}
func (sl *SystemLog) SetMessage(message string) {
	sl.Message = message
}
func (sl *SystemLog) SetObject(object string) {
	sl.Object = object
}
func (sl *SystemLog) SetStatusCode(code int) {
	sl.StatusCode = code
}
func (sl *SystemLog) GetSpecialUser() string {
	return sl.SpecialUser
}

func isBaseModel(text string, secondLevel bool) (bool, string) {
	if isExemptModel(text) {
		return false, text
	}
	for _, model := range Base_models {
		if !secondLevel {
			if model == text {
				return true, text
			}
		} else {
			for _, secondary_model := range SecondLevel_base_models {
				if secondary_model == text {
					return true, text
				}
			}
		}
	}
	return false, text
}
func isExemptModel(text string) bool {
	for _, model := range Exempt_models {
		if model == text {
			return true
		}
	}
	return false
}

package types

import "unicode"

type User struct {
	PublicId string `json:"id"`
}

type Administrator struct {
}

type Grantee struct {
}

type SiteManager struct {
}

type UserLogin struct {
}

func Capitalize(s string) string {
	if len(s) == 0 {
		return s
	}

	r := []rune(s)               // Convert string to rune slice for Unicode safety.
	r[0] = unicode.ToUpper(r[0]) // Capitalize the first rune.
	return string(r)             // Convert rune slice back to string.

}


package server

import (
	"fmt"
	"strings"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
)

func VerifyMachineNames(endpoints map[string]*types.Endpoint) error {
	for key, endpoint := range endpoints {
		for secondKey, duplicate := range endpoints {
			if key != secondKey {
				if strings.ToLower(endpoint.MachineName) == strings.ToLower(duplicate.MachineName) {
					return fmt.Errorf("duplicate services")
				}
			}
		}
	}
	return nil
}

package server

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/http/httputil"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
)

type Server struct {
	id          string
	EndPoints   types.MapEndPoint
	Proxies     map[string]*httputil.ReverseProxy
	Credentials types.ManagerLogInCredentials
}

func (srv *Server) FetchServices() *[]types.PublicService {
	req, err := http.NewRequest("GET", types.CentralDomain+"manager/service/", nil)
	if err != nil {
		log.Fatal("ServerStartUp::\n Failed to generate request(fetchServices)")
	}
	req.Header.Set("Authorization", "Bearer "+srv.Credentials.Access)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal("ServerStartUp::\n Failed to execute request(fetchServices)")
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatal("Failed to decode boby (fetchServices)")
	}
	var services []types.PublicService
	if err := json.Unmarshal(body, &services); err != nil {
		log.Fatal("ServerStartUp::\n Failed to decode response(fetchServices)\n" + err.Error())
	}
	return &services
}

func (srv *Server) GenerateEndPoints() {
	services := srv.FetchServices()
	camEndpoint, err := NewEndpoint("c_a_m", "c_a_m", "", types.Central_access_managementUrl, []string{"GET", "PATCH", "DELETE", "POST"}, "")
	if err != nil {
		log.Fatal(err)
	}
	endPoints := map[string]*types.Endpoint{}
	endPoints[camEndpoint.MachineName] = camEndpoint

	for _, service := range *services {
		endpoint, err := NewEndpoint(service.Title, service.MachineName, "", service.URL, service.Methods, service.PublicId)
		if err != nil {
			log.Fatal("Failed to create endpoint: \n\t" + service.String())
		}
		endPoints[service.MachineName] = endpoint
	}
	if err := VerifyMachineNames(endPoints); err != nil {
		log.Fatal("Duplicate ServicesNames ")
	}
	srv.EndPoints = endPoints
}
func (srv *Server) FetchEndpoints() {
	// endPoint1, err := NewEndpoint("server1", "service", "/service", rudiUrl, []string{"GET", "PATCH"})
	// if err != nil {
	// 	log.Fatal(err)
	// }
	// endPoint2, err := NewEndpoint("server2", "stuff", "/stuff", rudiUrl2, []string{"GET", "PATCH"})
	// if err != nil {
	// 	log.Fatal(err)
	// }

	srv.GenerateEndPoints()
	srv.CreateProxies()
}

func (srv *Server) CreateProxies() {
	srv.Proxies = map[string]*httputil.ReverseProxy{}
	for _, endpoint := range srv.EndPoints {
		proxy := httputil.NewSingleHostReverseProxy(endpoint.URL)
		proxy.ModifyResponse = func(response *http.Response) error {
			// modify page data
			return nil
		}
		srv.Proxies[endpoint.MachineName] = proxy
	}
	fmt.Println("proxies at first", srv.Proxies)

}

func (srv *Server) HandleRequest(auth *types.Authenticator, code *int) {
	proxy, exists := srv.Proxies[auth.Service]
	if !exists {
		data := map[string]string{"message": "Service Not Found"}
		auth.ResponseWriter.WriteHeader(http.StatusNotFound)
		json.NewEncoder(auth.ResponseWriter).Encode(data)
		log.Println("Proxy not found")
	}
	proxy.ModifyResponse = func(response *http.Response) error {
		*code = response.StatusCode
		return nil
	}
	log.Println("this is the proxy: ", proxy)

	// proxy.ServeHTTP(auth.ResponseWriter, auth.Request)
	// return
}

func (srv *Server) HandleServe(auth *types.Authenticator, code *int) {
	srv.HandleRequest(auth, code)
}
func (srv *Server) Serve(w http.ResponseWriter, r *http.Request) {
	var code int = 0
	authenticator := types.NewAuthenticator(r)
	if err := authenticator.PopulateAuthenticate(&srv.EndPoints, &srv.Credentials); err != nil {
		log.Println(err)
		return
	}
	srv.HandleServe(authenticator, &code)
	if authenticator.Service == "c_a_m" {
		authenticator.SystemLog.SetStatusCode(code)
		fmt.Printf("Status Code is %d\n", code)
	} else {
		authenticator.SystemLog.SetObject("PublicService")
		authenticator.SystemLog.SetRecordId(authenticator.ServiceId)
		authenticator.SystemLog.SetMessage("Accessed Service: " + authenticator.Service + " at " + authenticator.Request.URL.Path)
	}
}

func (srv *Server) StartGateway(port string) {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		srv.Serve(w, r)
		return
	})

	_ = http.ListenAndServe(":"+port, nil)
}

func NewServer() *Server {
	credentials := generateManagerCredentials()
	credentials.StartCredentials()

	server := Server{Credentials: *credentials}
	server.FetchEndpoints()
	return &server
}


package server

import (
	"net/url"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/verify"
)

func NewEndpoint(serviceName string, machineName string, fixedPath string, serviceUrl string, methods []string, id string) (*types.Endpoint, error) {
	formattedUrl, err := url.Parse(serviceUrl)
	if err != nil {
		return nil, err
	}
	if err := verify.VerifyMethods(methods); err != nil {
		return nil, err
	}

	return &types.Endpoint{
		ServiceName: serviceName,
		MachineName: machineName,
		URL:         formattedUrl,
		FixedPath:   fixedPath,
		Methods:     methods,
		ServiceId:   id,
	}, nil

}

func generateManagerCredentials() *types.ManagerLogInCredentials {
	return &types.ManagerLogInCredentials{
		ManagerUserName: "A3R0",
		ManagerPassword: "bsrvnttngjltzl",
		Email:           "erlsontmadara@gmail.com",
		Password:        "1234bsrvnt",
	}
}


package service

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httputil"
	"time"

	"github.com/go-kit/log"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
)

// type Middleware func(*BasicService) Service
type Middleware func(Service) Service

type LoggingMiddleware struct {
	log                log.Logger
	ServiceName        string
	ServiceMachineName string
	ServiceId          string
	next               Service
	Proxy              *httputil.ReverseProxy
	Credentials        *types.ManagerLogInCredentials
}

func NewLoggingMiddleware(logger log.Logger, credentials *types.ManagerLogInCredentials) Middleware {
	return func(service Service) Service {
		return &LoggingMiddleware{
			log:                logger,
			ServiceName:        service.GetServiceName(),
			ServiceMachineName: service.GetServiceMachineName(),
			ServiceId:          service.GetServiceId(),
			Proxy:              service.GetProxy(),
			Credentials:        credentials,
			next:               service,
		}
	}
}

func (md *LoggingMiddleware) LogData(auth *types.Authenticator) error {
	logOutput, err := auth.SystemLog.GenerateLog()
	if err != nil {
		return fmt.Errorf("failed to generate log")
	}
	jsonLog, err := json.Marshal(logOutput)
	if err != nil {
		return fmt.Errorf("failed to marshal log data")
	}
	fmt.Println(logOutput)
	req, err := http.NewRequest("POST", types.CentralDomain+"manager/log/manager/", bytes.NewBuffer(jsonLog))
	if err != nil {
		return fmt.Errorf("failed create the request to push the log")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Add("Authorization", "Bearer "+md.Credentials.Access)
	// err = md.producer.Produce(
	// 	&kafka.Message{
	// 		TopicPartition: kafka.TopicPartition{Topic: &types.KafkaLoggerTopic, Partition: kafka.PartitionAny},
	// 		Value:          jsonLog},
	// 	nil,
	// )
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return fmt.Errorf("failed to push data to central access management")
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		return fmt.Errorf("failed to push log: server side")
	}
	return nil

}

func (md *LoggingMiddleware) GetServiceName() string {
	return md.ServiceName
}
func (md *LoggingMiddleware) GetServiceId() string {
	return md.ServiceId
}
func (md *LoggingMiddleware) GetServiceMachineName() string {
	return md.ServiceMachineName
}
func (md *LoggingMiddleware) GetProxy() *httputil.ReverseProxy {
	return md.Proxy
}

func (md *LoggingMiddleware) Serve(auth *types.Authenticator) (*types.Authenticator, error) {
	defer func(start time.Time) {
		err := md.LogData(auth)
		md.log.Log("method", md.ServiceId, "took", time.Since(start), "err", err)
	}(time.Now())
	return md.next.Serve(auth)
}

func NewInstrumentingMiddleware(globalMetricsHolder *types.GlobalMetricsHolder) Middleware {
	return func(next Service) Service {
		globalMetricsHolder.GlobalServicesCounter.Inc()
		return &InstrumentingMiddleware{
			globalReqCounter: globalMetricsHolder.GlobalReqCounter,
			globalErrCounter: globalMetricsHolder.GlobalErrCounter,
			globalReqLatency: globalMetricsHolder.GlobalReqLatency,
			globalErrLatency: globalMetricsHolder.GlobalErrLatency,
			serviceReqCounter: promauto.NewCounter(prometheus.CounterOpts{
				Namespace: next.GetServiceMachineName() + "_request_counter",
				Name:      next.GetServiceMachineName(),
			}),

			serviceErrCounter: promauto.NewCounter(prometheus.CounterOpts{
				Namespace: next.GetServiceMachineName() + "_error_counter",
				Name:      next.GetServiceMachineName(),
			}),

			serviceReqLatency: promauto.NewHistogram(prometheus.HistogramOpts{
				Namespace: next.GetServiceMachineName() + "_request_latency",
				Name:      next.GetServiceMachineName(),
				Buckets:   []float64{0.1, 0.5, 1.0},
			}),

			serviceErrLatency: promauto.NewHistogram(prometheus.HistogramOpts{
				Namespace: next.GetServiceMachineName() + "_error_latency",
				Name:      next.GetServiceMachineName(),
				Buckets:   []float64{0.1, 0.5, 1.0},
			}),

			next:               next,
			ServiceName:        next.GetServiceName(),
			ServiceMachineName: next.GetServiceMachineName(),
			ServiceId:          next.GetServiceId(),
			Proxy:              next.GetProxy(),
		}
	}
}

type InstrumentingMiddleware struct {
	globalReqCounter   prometheus.Counter
	serviceReqCounter  prometheus.Counter
	globalErrCounter   prometheus.Counter
	serviceErrCounter  prometheus.Counter
	globalReqLatency   prometheus.Histogram
	serviceReqLatency  prometheus.Histogram
	globalErrLatency   prometheus.Histogram
	serviceErrLatency  prometheus.Histogram
	next               Service
	ServiceName        string
	ServiceMachineName string
	ServiceId          string
	Proxy              *httputil.ReverseProxy
}

func (isMiddleware *InstrumentingMiddleware) Serve(auth *types.Authenticator) (returnAuth *types.Authenticator, err error) {
	defer func(start time.Time) {
		if err != nil {
			isMiddleware.globalErrCounter.Inc()
			isMiddleware.serviceErrCounter.Inc()
			isMiddleware.globalErrLatency.Observe(float64(time.Since(start).Seconds()))
			isMiddleware.serviceErrLatency.Observe(float64(time.Since(start).Seconds()))

		}
		isMiddleware.serviceReqCounter.Inc()
		isMiddleware.globalReqCounter.Inc()
		isMiddleware.globalReqLatency.Observe(float64(time.Since(start).Seconds()))
		isMiddleware.serviceReqLatency.Observe(float64(time.Since(start).Seconds()))

	}(time.Now())
	returnAuth, err = isMiddleware.next.Serve(auth)
	return
}

func (isMiddleware *InstrumentingMiddleware) GetServiceName() string {
	return isMiddleware.ServiceName
}
func (isMiddleware *InstrumentingMiddleware) GetServiceMachineName() string {
	return isMiddleware.ServiceMachineName
}
func (isMiddleware *InstrumentingMiddleware) GetServiceId() string {
	return isMiddleware.ServiceId
}
func (isMiddleware *InstrumentingMiddleware) GetProxy() *httputil.ReverseProxy {
	return isMiddleware.Proxy
}



package service

import (
	"compress/flate"
	"compress/gzip"
	"encoding/json"
	"io"
	"regexp"
	"strings"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
	"github.com/andybalholm/brotli"
)

func injectBaseTag(html []byte, serviceMachineName string, originalDomain string) []byte {
	re := regexp.MustCompile(`href\s*=\s*"(.*?)"`)

	updated := re.ReplaceAllFunc(html, func(match []byte) []byte {
		hrefMatch := re.FindSubmatch(match)
		if len(hrefMatch) < 2 {
			return match
		}

		original := string(hrefMatch[1])

		// Skip absolute URLs that aren't the original domain
		if strings.HasPrefix(original, "http://") || strings.HasPrefix(original, "https://") {
			if !strings.HasPrefix(original, originalDomain) {
				return match // leave external links alone
			}
			// Strip domain and treat like relative
			original = strings.TrimPrefix(original, originalDomain)
		}

		// Clean relative path
		cleanPath := strings.TrimLeft(original, "/.")
		newHref := types.GatewayDomain + "/" + serviceMachineName + "/" + cleanPath
		return []byte(`href="` + newHref + `"`)
	})

	return updated

	// lower := bytes.ToLower(html)
	// headIndex := bytes.Index(lower, []byte("<head>"))
	// if headIndex == -1 {
	// 	return html // no <head> found
	// }

	// insertPos := headIndex + len("<head>")
	// baseTag := `<base href="` + types.GatewayDomain + serviceMachineName + `/">`
	// return append(html[:insertPos], append([]byte(baseTag), html[insertPos:]...)...)
}

func rewriteCSSUrlsToGateway(css []byte, serviceName string, originalDomain string) []byte {
	gatewayDomain := types.GatewayDomain

	re := regexp.MustCompile(`url\(["']?(.*?)["']?\)`)

	return re.ReplaceAllFunc(css, func(match []byte) []byte {
		urlMatch := re.FindSubmatch(match)
		if len(urlMatch) < 2 {
			return match
		}

		original := string(urlMatch[1])

		// Skip external links
		if strings.HasPrefix(original, "http://") || strings.HasPrefix(original, "https://") {
			if !strings.HasPrefix(original, originalDomain) {
				return match // skip external domains
			}
			// Treat original domain as internal, strip it
			original = strings.TrimPrefix(original, originalDomain)
		}

		cleanPath := strings.TrimLeft(original, "/.")
		newURL := gatewayDomain + "/" + serviceName + "/" + cleanPath

		return []byte(`url("` + newURL + `")`)
	})
}

func decompressBody(body io.Reader, encoding string) ([]byte, error) {
	switch encoding {
	case "gzip":
		r, err := gzip.NewReader(body)
		if err != nil {
			return nil, err
		}
		defer r.Close()
		return io.ReadAll(r)
	case "deflate":
		r := flate.NewReader(body)
		defer r.Close()
		return io.ReadAll(r)
	case "br":
		r := brotli.NewReader(body)
		return io.ReadAll(r)
	default:
		return io.ReadAll(body) // uncompressed
	}
}

func rewriteJSONUrlsRecursive(jsonData []byte, serviceName, originalDomain string) []byte {
	var data interface{}
	if err := json.Unmarshal(jsonData, &data); err != nil {
		return jsonData
	}

	rewritten := rewriteURLsInValue(data, serviceName, originalDomain)

	result, err := json.Marshal(rewritten)
	if err != nil {
		return jsonData // fallback to original
	}

	return result
}

func rewriteURLsInValue(value interface{}, serviceName, originalDomain string) interface{} {
	switch v := value.(type) {
	case map[string]interface{}:
		result := make(map[string]interface{})
		for k, val := range v {
			result[k] = rewriteURLsInValue(val, serviceName, originalDomain)
		}
		return result
	case []interface{}:
		result := make([]interface{}, len(v))
		for i, val := range v {
			result[i] = rewriteURLsInValue(val, serviceName, originalDomain)
		}
		return result
	case string:
		// Check if this string looks like a URL and rewrite it
		if strings.HasPrefix(v, originalDomain) {
			path := strings.TrimPrefix(v, originalDomain)
			path = strings.TrimLeft(path, "/")
			return types.GatewayDomain + "/" + serviceName + "/" + path
		}
		return v
	default:
		return v
	}
}

func compressBody(w io.Writer, data []byte, encoding string) error {
	switch encoding {
	case "gzip":
		gz := gzip.NewWriter(w)
		defer gz.Close()
		_, err := gz.Write(data)
		return err
	case "deflate":
		fl, err := flate.NewWriter(w, flate.DefaultCompression)
		if err != nil {
			return err
		}
		defer fl.Close()
		_, err = fl.Write(data)
		return err
	case "br":
		br := brotli.NewWriter(w)
		defer br.Close()
		_, err := br.Write(data)
		return err
	default:
		_, err := w.Write(data)
		return err
	}
}

func rewriteJSONUrls(jsonData []byte, serviceName, originalDomain string) []byte {
	// Parse JSON to ensure we don't break structure
	var data interface{}
	if err := json.Unmarshal(jsonData, &data); err != nil {
		// If JSON is invalid, return as-is
		return jsonData
	}

	// Convert back to string for regex processing
	jsonStr := string(jsonData)

	// Match URLs in JSON values (handles both quoted strings and unescaped URLs)
	urlRegex := regexp.MustCompile(`"(https?://[^"]+)"`)

	result := urlRegex.ReplaceAllStringFunc(jsonStr, func(match string) string {
		// Extract the URL (remove quotes)
		url := match[1 : len(match)-1]

		// Only rewrite URLs that match your original domain
		if strings.HasPrefix(url, originalDomain) {
			// Strip original domain and rebuild with gateway
			path := strings.TrimPrefix(url, originalDomain)
			path = strings.TrimLeft(path, "/")
			newURL := types.GatewayDomain + "/" + serviceName + "/" + path
			return `"` + newURL + `"`
		}

		// Return unchanged if it's an external URL
		return match
	})

	return []byte(result)
}


package service

import (
	"bytes"
	"crypto/tls"
	"fmt"
	"io"
	normalLog "log"
	"strconv"
	"strings"

	"github.com/go-kit/log"

	"net/http"
	"net/http/httputil"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/system"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
)

type Service interface {
	Serve(*types.Authenticator) (*types.Authenticator, error)
	GetServiceName() string
	GetServiceId() string
	GetServiceMachineName() string
	GetProxy() *httputil.ReverseProxy
}

type BasicService struct {
	Endpoint           *types.Endpoint
	ServiceName        string
	ServiceMachineName string
	ServiceId          string
	Proxy              *httputil.ReverseProxy
}

func (srvc *BasicService) GetServiceName() string {
	return srvc.ServiceName
}
func (srvc *BasicService) GetServiceId() string {
	return srvc.ServiceId
}
func (srvc *BasicService) GetServiceMachineName() string {
	return srvc.ServiceMachineName
}
func (srvc *BasicService) GetProxy() *httputil.ReverseProxy {
	return srvc.Proxy
}

func (srvc *BasicService) Serve(auth *types.Authenticator) (*types.Authenticator, error) {
	if auth.Service != srvc.ServiceMachineName {
		normalLog.Println("Proxy not found")
		return auth, fmt.Errorf("service not found")
	}
	proxy := *srvc.Proxy
	previousModifyResponse := proxy.ModifyResponse
	newProxy := &proxy
	proxy.ModifyResponse = func(resp *http.Response) error {
		contentType := resp.Header.Get("Content-Type")

		encoding := resp.Header.Get("Content-Encoding")
		originalEncoding := encoding // remember it for recompression

		decompressed, err := decompressBody(resp.Body, encoding)
		if err != nil {
			return err
		}
		_ = resp.Body.Close()

		// Remove encoding so we can safely modify
		resp.Header.Del("Content-Encoding")
		targetURL := srvc.Endpoint.URL.Scheme + "://" + srvc.Endpoint.URL.Host
		if uri := srvc.Endpoint.URL.RequestURI(); uri != "/" {
			targetURL += uri
		}
		var modified []byte
		if strings.Contains(contentType, "text/html") {
			modified = injectBaseTag(decompressed, srvc.Endpoint.MachineName, targetURL)
		} else if strings.Contains(contentType, "text/css") {
			modified = rewriteCSSUrlsToGateway(decompressed, srvc.Endpoint.MachineName, targetURL)
		} else if (strings.Contains(contentType, "application/json") || strings.Contains(contentType, "text/json")) && strings.ToLower(auth.SystemLog.GetSpecialUser()) == "citizen" {
			// Add JSON URL rewriting here
			modified = rewriteJSONUrls(decompressed, srvc.Endpoint.MachineName, targetURL)
		} else {
			modified = decompressed
		}

		// Recompress to match original encoding
		var finalBody bytes.Buffer
		if originalEncoding != "" {
			err := compressBody(&finalBody, modified, originalEncoding)
			if err != nil {
				return err
			}
			resp.Header.Set("Content-Encoding", originalEncoding)
		} else {
			finalBody.Write(modified)
		}

		// Set updated body and headers
		resp.Body = io.NopCloser(&finalBody)
		resp.ContentLength = int64(finalBody.Len())
		resp.Header.Set("Content-Length", strconv.Itoa(finalBody.Len()))

		return nil
	}
	newProxy.ModifyResponse = func(response *http.Response) error {
		if previousModifyResponse != nil {
			if err := previousModifyResponse(response); err != nil {
				return err
			}
		}
		auth.Code = &response.StatusCode
		return nil
	}
	normalLog.Println("this is the proxy: ", srvc.Proxy)
	auth.Proxy = &proxy
	return auth, nil
}

func NewBasicService(endPoint *types.Endpoint) *BasicService {
	proxy := httputil.NewSingleHostReverseProxy(endPoint.URL)
	proxy.Transport = &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	proxy.Director = func(r *http.Request) {
		r.URL.Scheme = endPoint.URL.Scheme
		r.URL.Host = endPoint.URL.Host
		r.Host = endPoint.URL.Host
		r.URL.Path = types.RefineUrl(endPoint.URL.Path + "/" + r.URL.Path)
		if ua := r.Header.Get("User-Agent"); ua != "" {
			r.Header.Set("User-Agent", ua)
		}
	}
	return &BasicService{
		Endpoint:           endPoint,
		ServiceName:        endPoint.ServiceName,
		ServiceMachineName: endPoint.MachineName,
		ServiceId:          endPoint.ServiceId,
		Proxy:              proxy,
	}
}

// func NewProducer() (*kafka.Producer, error) {
// 	producer, err := kafka.NewProducer(&kafka.ConfigMap{
// 		"bootstrap.servers": "localhost",
// 	})
// 	if err != nil {
// 		return nil, fmt.Errorf("failed to create the producer: %s", err.Error())
// 	}
// 	go func() {
// 		for e := range producer.Events() {
// 			switch ev := e.(type) {
// 			case *kafka.Message:
// 				if ev.TopicPartition.Error != nil {
// 					normalLog.Printf("Delivery failed: %v\n ", ev.TopicPartition)
// 				} else {
// 					normalLog.Printf("Delivered message: to %v\n", ev.TopicPartition)
// 				}
// 			}
// 		}
// 	}()
// 	return producer, nil
// }

func New(logger log.Logger, server *system.Server, globalMetricsHolder *types.GlobalMetricsHolder) []Service {
	var services []Service
	for _, endP := range server.EndPoints {
		{
			basicService := NewBasicService(endP)
			service := NewLoggingMiddleware(logger, &server.Credentials)(basicService)
			service = NewInstrumentingMiddleware(globalMetricsHolder)(service)
			services = append(services, service)
		}

	}
	return services
}


package serviceEndpoint

import (
	"context"
	"fmt"
	"time"

	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/metrics"
	"github.com/go-kit/log"
)

func InstrumentingMiddleware(duration metrics.Histogram) endpoint.Middleware {
	return func(e endpoint.Endpoint) endpoint.Endpoint {
		return func(ctx context.Context, request interface{}) (response interface{}, err error) {
			defer func(begin time.Time) {
				duration.With("success", fmt.Sprint(err == nil)).Observe(time.Since(begin).Seconds())
			}(time.Now())
			return e(ctx, request)
		}
	}
}

func LoggingMiddleware(logger log.Logger) endpoint.Middleware {
	return func(e endpoint.Endpoint) endpoint.Endpoint {
		return func(ctx context.Context, request interface{}) (response interface{}, err error) {
			defer func(begin time.Time) {
				logger.Log("transport_error", err, "took", time.Since(begin))
			}(time.Now())
			return e(ctx, request)
		}
	}
}


package serviceEndpoint

import (
	"context"
	"time"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/service"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
	"github.com/go-kit/kit/circuitbreaker"
	"github.com/go-kit/kit/endpoint"
	"github.com/go-kit/kit/metrics"
	"github.com/go-kit/kit/ratelimit"
	"github.com/go-kit/log"
	"github.com/sony/gobreaker"
	"golang.org/x/time/rate"
)

type Set struct {
	ServiceMachineName string
	ServiceEndpoint    endpoint.Endpoint
}

func New(service service.Service, logger log.Logger, duration metrics.Histogram) *Set {

	var serviceEndpoint endpoint.Endpoint
	{
		serviceEndpoint = MakeServiceEndpoint(service)
		serviceEndpoint = ratelimit.NewErroringLimiter(rate.NewLimiter(rate.Every(time.Second), 20))(serviceEndpoint)
		serviceEndpoint = circuitbreaker.Gobreaker(gobreaker.NewCircuitBreaker(gobreaker.Settings{}))(serviceEndpoint)
		serviceEndpoint = LoggingMiddleware(log.With(logger, "method", service.GetServiceName()))(serviceEndpoint)
		serviceEndpoint = InstrumentingMiddleware(duration.With("method", service.GetServiceName()))(serviceEndpoint)

	}
	return &Set{
		ServiceEndpoint:    serviceEndpoint,
		ServiceMachineName: service.GetServiceMachineName(),
	}
}

func MakeServiceEndpoint(service service.Service) endpoint.Endpoint {
	return func(ctc context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*types.Authenticator)
		return service.Serve(req)
	}
}


package serviceTransport

import (
	"context"
	"encoding/json"
	"fmt"
	normalLog "log"
	"net/http"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/serviceEndpoint"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/system"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
	"github.com/go-kit/kit/transport"
	httptransport "github.com/go-kit/kit/transport/http"
	"github.com/go-kit/log"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

func errorEncoder(ctx context.Context, err error, w http.ResponseWriter) {
	data := map[string]string{"message": err.Error()}
	switch err.Error() {
	case "authentication failed":
		w.WriteHeader(http.StatusUnauthorized)
	case "service not found":
		w.WriteHeader(http.StatusNotFound)
	case "service error":
		w.WriteHeader(http.StatusInternalServerError)
	case "service unauthorized":
		w.WriteHeader(http.StatusUnauthorized)
	default:
		break
	}
	json.NewEncoder(w).Encode(data)
	normalLog.Println("This is coming from the error Encoder -> ", err)
}

func NewHTTPHandler(sets []*serviceEndpoint.Set, server *system.Server, logger log.Logger) http.Handler {
	options := []httptransport.ServerOption{
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerErrorHandler(transport.NewLogErrorHandler(logger)),
	}

	m := http.NewServeMux()
	for _, set := range sets {
		fmt.Println("/" + set.ServiceMachineName)
		m.Handle("/"+set.ServiceMachineName+"/", httptransport.NewServer(
			set.ServiceEndpoint,
			makeDecoderHttpServiceRequest(server),
			makeEncoderHttpServiceResponse(server),
			options...,
		))
	}
	m.Handle("/promMetrics", promhttp.Handler())

	return m

}

func makeDecoderHttpServiceRequest(server *system.Server) httptransport.DecodeRequestFunc {
	return func(ctx context.Context, request *http.Request) (req interface{}, err error) {
		auth := types.NewAuthenticator(request)
		normalLog.Println(auth.Request.URL)
		if err := auth.PopulateAuthenticate(&server.EndPoints, &server.Credentials); err != nil {
			return nil, err
		}
		return auth, nil
	}
}
func makeEncoderHttpServiceResponse(server *system.Server) httptransport.EncodeResponseFunc {
	return func(ctx context.Context, w http.ResponseWriter, response interface{}) error {
		auth := response.(*types.Authenticator)
		// user := auth.SystemLog.GetSpecialUser()
		// if !(user == "manager" || user == "admin" || user == "grantee") {
		// 	previousFunc := auth.Proxy.ModifyResponse
		// 	auth.Proxy.ModifyResponse = func(resp *http.Response) error {
		// 		if previousFunc != nil {
		// 			if err := previousFunc(resp); err != nil {
		// 				return err
		// 			}
		// 		}
		// 		contentType := resp.Header.Get("Content-Type")
		// 		// Only process text-based responses
		// 		if !(strings.Contains(contentType, "application/json")) {
		// 			return nil // Skip binary or irrelevant types (e.g., images, PDF, etc.)
		// 		}
		// 		// Read and close the original body
		// 		bodyBytes, err := io.ReadAll(resp.Body)
		// 		if err != nil {
		// 			return err
		// 		}
		// 		resp.Body.Close()
		// 		modifiedBody := string(bodyBytes)
		// 		// Replace all occurrences of internal service URLs with gateway paths
		// 		for _, endPoint := range server.EndPoints {
		// 			targetURL := endPoint.URL.Scheme + "://" + endPoint.URL.Host
		// 			if uri := endPoint.URL.RequestURI(); uri != "/" {
		// 				targetURL += uri
		// 			}
		// 			gatewayPath := "http://127.0.0.1:8020/" + endPoint.MachineName
		// 			modifiedBody = strings.ReplaceAll(modifiedBody, targetURL, gatewayPath)
		// 		}
		// 		// Reset response body with modified content
		// 		resp.Body = io.NopCloser(bytes.NewBufferString(modifiedBody))
		// 		resp.ContentLength = int64(len(modifiedBody))
		// 		resp.Header.Set("Content-Length", strconv.Itoa(len(modifiedBody)))
		// 		return nil
		// 	}
		// }
		// Serve through proxy
		auth.Proxy.ServeHTTP(w, auth.Request)
		return nil
	}
}

// func makeEncoderHttpServiceResponse(server *system.Server) httptransport.EncodeResponseFunc {
// 	return func(ctx context.Context, w http.ResponseWriter, response interface{}) error {
// 		auth := response.(*types.Authenticator)
// 		// alterBody(auth.Proxy)
// 		previousFunc := auth.Proxy.ModifyResponse
// 		auth.Proxy.ModifyResponse = func(resp *http.Response) error {
// 			if previousFunc != nil {
// 				previousFunc(resp)
// 			}
// 			contentType := resp.Header.Get("Content-Type")
// 			if !strings.HasPrefix(contentType, "text/") && !strings.Contains(contentType, "html") {
// 				return nil // skip non-text responses
// 			}

// 			// Read the body
// 			bodyBytes, err := io.ReadAll(resp.Body)
// 			if err != nil {
// 				return err
// 			}
// 			resp.Body.Close()
// 			modifiedBody := string(bodyBytes)
// 			// Replace all links starting with oldDomain
// 			for _, endPoint := range server.EndPoints {
// 				modifiedBody = strings.ReplaceAll(modifiedBody, endPoint.URL.Scheme+"://"+endPoint.URL.Host+endPoint.URL.RequestURI(), "http://127.0.0.1:8020/"+endPoint.MachineName)
// 			}

// 			// Replace the body with the modified content
// 			resp.Body = io.NopCloser(bytes.NewBufferString(modifiedBody))
// 			resp.ContentLength = int64(len(modifiedBody))
// 			resp.Header.Set("Content-Length", strconv.Itoa(len(modifiedBody)))
// 			return nil
// 		}
// 		auth.Proxy.ServeHTTP(w, auth.Request)
// 		return nil
// 	}
// }

// func encodeHttpServiceResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
// 	auth := response.(*types.Authenticator)
// 	// alterBody(auth.Proxy)
// 	alterBody(auth)
// 	auth.Proxy.ServeHTTP(w, auth.Request)
// 	return nil
// }

// func alterBody(auth *types.Authenticator) {
// 	auth.Proxy.ModifyResponse = makeAlterBodyFunc(auth.Proxy, auth.ServiceMachineName)
// }

// func makeAlterBodyFunc(proxy *httputil.ReverseProxy, serviceMachineName string) func(r *http.Response) error {
// 	previousFunc := proxy.ModifyResponse
// 	return func(resp *http.Response) error {
// 		if previousFunc != nil {
// 			previousFunc(resp)
// 		}
// 		// Only modify text-based responses
// 		contentType := resp.Header.Get("Content-Type")
// 		if !strings.HasPrefix(contentType, "text/") && !strings.Contains(contentType, "html") {
// 			return nil // skip non-text responses
// 		}

// 		// Read the body
// 		bodyBytes, err := io.ReadAll(resp.Body)
// 		if err != nil {
// 			return err
// 		}
// 		resp.Body.Close()

// 		// Replace all links starting with oldDomain
// 		modifiedBody := strings.ReplaceAll(string(bodyBytes), oldDomain, "http://127.0.0.1:8020/"+serviceMachineName)

// 		// Replace the body with the modified content
// 		resp.Body = io.NopCloser(bytes.NewBufferString(modifiedBody))
// 		resp.ContentLength = int64(len(modifiedBody))
// 		resp.Header.Set("Content-Length", strconv.Itoa(len(modifiedBody)))
// 		return nil
// 	}
// }

// func createResponseModifier(gatewayHost, gatewayBase, token string, server *server.Server, previousFunc func(*http.Response) error) func(*http.Response) error {
// 	// Token is passed as a parameter

// 	return func(resp *http.Response) error {
// 		// Check if content type should be processed
// 		err := previousFunc(resp); err != nil{
// 			return err
// 		}
// 		contentType := resp.Header.Get("Content-Type")
// 		shouldProcess := strings.Contains(contentType, "text/html") ||
// 			strings.Contains(contentType, "text/css") ||
// 			strings.Contains(contentType, "application/javascript") ||
// 			strings.Contains(contentType, "application/json") ||
// 			strings.Contains(contentType, "text/xml")

// 		if !shouldProcess {
// 			return nil
// 		}

// 		// Read the original response body
// 		body, err := io.ReadAll(resp.Body)
// 		if err != nil {
// 			return err
// 		}
// 		resp.Body.Close()

// 		// Function to add token to URL
// 		addTokenToURL := func(urlStr string) string {
// 			parsedURL, err := url.Parse(urlStr)
// 			if err != nil {
// 				// If URL parsing fails, just append the token as a query parameter
// 				if strings.Contains(urlStr, "?") {
// 					return urlStr + "&token=" + token
// 				}
// 				return urlStr + "?token=" + token
// 			}

// 			q := parsedURL.Query()
// 			q.Set("token", token)
// 			parsedURL.RawQuery = q.Encode()
// 			return parsedURL.String()
// 		}

// 		// Replace absolute URLs (with protocol)
// 		// First, create a replacement that includes the token
// 		for _, endPoint := range server.EndPoints {
// 			targetURL := endPoint.URL.Scheme + "://" + endPoint.URL.Host
// 			if uri := endPoint.URL.RequestURI(); uri != "/" {
// 					targetURL += uri
// 			}
// 			tokenizedGatewayURL := addTokenToURL(gatewayBase)
// 			modifiedBody := bytes.ReplaceAll(body, []byte(targetURL), []byte(tokenizedGatewayURL))
// 			targetHost := endPoint.URL.Host
// 			if uri := endPoint.URL.RequestURI(); uri != "/" {
// 				targetHost += uri
// 			}
// 			// Handle protocol-relative URLs with token
// 			protocolRelativePattern := regexp.MustCompile(`(//)` + targetHost + `(/[^"'\s>]*)`)
// 			modifiedBody = protocolRelativePattern.ReplaceAllFunc(modifiedBody, func(match []byte) []byte {
// 				parts := protocolRelativePattern.FindSubmatch(match)
// 				if len(parts) >= 3 {
// 					path := string(parts[2])
// 					// Create a dummy URL to use the addTokenToURL function
// 					dummyURL := "http:" + string(parts[1]) + types.RefineUrl(gatewayHost + path)
// 					tokenizedURL := addTokenToURL(dummyURL)
// 					// Remove the protocol part added for parsing
// 					tokenizedURLWithoutProtocol := strings.TrimPrefix(tokenizedURL, "http:")
// 					return []byte(tokenizedURLWithoutProtocol)
// 				}
// 				return match
// 			})

// 			// Replace URLs in href and src attributes
// 			hrefSrcPattern := regexp.MustCompile(`(href|src)=["'](?:https?:)?//` + targetHost + `(/[^"']*)(["'])`)
// 			modifiedBody = hrefSrcPattern.ReplaceAllFunc(modifiedBody, func(match []byte) []byte {
// 				parts := hrefSrcPattern.FindSubmatch(match)
// 				if len(parts) >= 4 {
// 					attr := string(parts[1])
// 					path := string(parts[2])
// 					quote := string(parts[3])

// 					// Create URL with token
// 					fullURL := "https://" + types.RefineUrl(gatewayHost + path)
// 					tokenizedURL := addTokenToURL(fullURL)

// 					// Remove protocol for protocol-relative URLs if original was protocol-relative
// 					if !bytes.Contains(match, []byte("https:")) && !bytes.Contains(match, []byte("http:")) {
// 						tokenizedURL = strings.TrimPrefix(tokenizedURL, "https:")
// 					}

// 					return []byte(attr + "=" + quote + tokenizedURL + quote)
// 				}
// 				return match
// 			})
// 		}

// 		// Replace absolute paths (starting with /)
// 		absolutePathPattern := regexp.MustCompile(`(href|src|action)=["'](/[^"'?]*)([?][^"']*)?["']`)
// 		modifiedBody = absolutePathPattern.ReplaceAllFunc(modifiedBody, func(match []byte) []byte {
// 			parts := absolutePathPattern.FindSubmatch(match)
// 			if len(parts) >= 3 {
// 				attr := string(parts[1])
// 				path := string(parts[2])
// 				query := ""
// 				quote := `"`

// 				if len(parts) >= 4 && len(parts[3]) > 0 {
// 					query = string(parts[3])
// 				}
// 				if bytes.HasSuffix(match, []byte("'")) {
// 					quote = "'"
// 				}

// 				// Add token to query
// 				if query != "" {
// 					query = query + "&token=" + token
// 				} else {
// 					query = "?token=" + token
// 				}

// 				return []byte(attr + "=" + quote + path + query + quote)
// 			}
// 			return match
// 		})

// 		for _, endPoint := range server.EndPoints {
// 			targetHost := endPoint.URL.Host
// 			if uri := endPoint.URL.RequestURI(); uri != "/" {
// 				targetHost += uri
// 			}

// 			// Use regex for more complex URL replacements in HTML/JS
// 			if strings.Contains(contentType, "text/html") || strings.Contains(contentType, "application/javascript") {
// 				// Replace URLs in various formats that might appear in HTML or JS
// 				// For example: domain: "targetHost" or domain: 'targetHost'
// 				domainPattern := regexp.MustCompile(`(['"]\s*domain\s*['"]?\s*[:=]\s*['"])` + targetHost + `(['"])`)
// 				modifiedBody = domainPattern.ReplaceAll(modifiedBody, []byte("${1}"+gatewayHost+"${2}"))

// 				// Replace API endpoints or other patterns specific to your application
// 				apiPattern := regexp.MustCompile(`(api\.url\s*=\s*['"])` + targetHost + `(['"])`)
// 				modifiedBody = apiPattern.ReplaceAll(modifiedBody, []byte("${1}"+gatewayHost+"${2}"))

// 				// Handle JavaScript URL constructions
// 				jsURLPattern := regexp.MustCompile(`(["'])https?://` + targetHost + `(/[^"']+)(["'])`)
// 				modifiedBody = jsURLPattern.ReplaceAllFunc(modifiedBody, func(match []byte) []byte {
// 					parts := jsURLPattern.FindSubmatch(match)
// 					if len(parts) >= 4 {
// 						quote := string(parts[1])
// 						path := string(parts[2])
// 						endQuote := string(parts[3])

// 						fullURL := "https://" + types.RefineUrl(gatewayHost + path)
// 						tokenizedURL := addTokenToURL(fullURL)

// 						return []byte(quote + tokenizedURL + endQuote)
// 					}
// 					return match
// 				})
// 			}
// 		}
// 		// Update content length and replace body
// 		resp.ContentLength = int64(len(modifiedBody))
// 		resp.Body = io.NopCloser(bytes.NewReader(modifiedBody))

// 		// Update Location header if present (for redirects)
// 		if location := resp.Header.Get("Location"); location != "" {
// 			tokenizedLocation := addTokenToURL(strings.Replace(location, targetBase, gatewayBase, -1))
// 			resp.Header.Set("Location", tokenizedLocation)
// 		}

// 		return nil
// 	}
// }


package system

import (
	"encoding/json"
	"io"
	"log"
	"net/http"
	"net/url"

	server "github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/Server"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/verify"
)

type Server struct {
	id          string
	EndPoints   types.MapEndPoint
	Credentials types.ManagerLogInCredentials
}

func (srv *Server) FetchServices() *[]types.PublicService {
	req, err := http.NewRequest("GET", types.CentralDomain+"manager/service/", nil)
	if err != nil {
		log.Fatal("ServerStartUp::\n Failed to generate request(fetchServices)")
	}
	req.Header.Set("Authorization", "Bearer "+srv.Credentials.Access)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		log.Fatal("ServerStartUp::\n Failed to execute request(fetchServices)")
	}
	defer resp.Body.Close()
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatal("Failed to decode boby (fetchServices)")
	}
	var services []types.PublicService
	if err := json.Unmarshal(body, &services); err != nil {
		log.Fatal("ServerStartUp::\n Failed to decode response(fetchServices)\n" + err.Error())
	}
	return &services
}

func (srv *Server) GenerateEndPoints() {
	services := srv.FetchServices()
	camEndpoint, err := NewEndpoint("c_a_m", "c_a_m", "", types.Central_access_managementUrl, []string{"GET", "PATCH", "DELETE", "POST"}, "")
	if err != nil {
		log.Fatal(err)
	}
	endPoints := map[string]*types.Endpoint{}
	endPoints[camEndpoint.MachineName] = camEndpoint

	for _, service := range *services {
		endpoint, err := NewEndpoint(service.Title, service.MachineName, "", service.URL, service.Methods, service.PublicId)
		if err != nil {
			log.Fatal("Failed to create endpoint: \n\t" + service.String())
		}
		endPoints[service.MachineName] = endpoint
	}
	if err := server.VerifyMachineNames(endPoints); err != nil {
		log.Fatal("Duplicate ServicesNames ")
	}
	srv.EndPoints = endPoints
}
func (srv *Server) FetchEndpoints() {
	// endPoint1, err := NewEndpoint("server1", "service", "/service", rudiUrl, []string{"GET", "PATCH"})
	// if err != nil {
	// 	log.Fatal(err)
	// }
	// endPoint2, err := NewEndpoint("server2", "stuff", "/stuff", rudiUrl2, []string{"GET", "PATCH"})
	// if err != nil {
	// 	log.Fatal(err)
	// }

	srv.GenerateEndPoints()
}

func NewServer() *Server {
	server := Server{Credentials: *generateManagerCredentials()}
	server.Credentials.StartCredentials()
	server.FetchEndpoints()
	return &server
}
func NewEndpoint(serviceName string, machineName string, fixedPath string, serviceUrl string, methods []string, id string) (*types.Endpoint, error) {
	formattedUrl, err := url.Parse(serviceUrl)
	if err != nil {
		return nil, err
	}
	if err := verify.VerifyMethods(methods); err != nil {
		return nil, err
	}

	return &types.Endpoint{
		ServiceName: serviceName,
		MachineName: machineName,
		URL:         formattedUrl,
		FixedPath:   fixedPath,
		Methods:     methods,
		ServiceId:   id,
	}, nil

}
func generateManagerCredentials() *types.ManagerLogInCredentials {
	return &types.ManagerLogInCredentials{
		ManagerUserName: "A3R0",
		ManagerPassword: "bsrvnttngjltzl",
		Email:           "erlsontmadara@gmail.com",
		Password:        "1234bsrvnt",
	}
}


package main

import (
	"net"
	"net/http"
	"os"

	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/service"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/serviceEndpoint"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/serviceTransport"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/kitGateway/system"
	"github.com/A3R0-01/Final-Year-Project--Centralized-Access-Management-Gateway/central-gateway/types"
	"github.com/go-kit/kit/metrics"
	"github.com/go-kit/kit/metrics/prometheus"
	"github.com/go-kit/log"
	stdprometheus "github.com/prometheus/client_golang/prometheus"
)

func main() {
	httpAddr := ":8020"
	var logger log.Logger
	{
		logger = log.NewLogfmtLogger(os.Stderr)
		logger = log.With(logger, "ts", log.DefaultTimestampUTC)
		logger = log.With(logger, "caller", log.DefaultCaller)
	}
	var duration metrics.Histogram
	{
		duration = prometheus.NewSummaryFrom(stdprometheus.SummaryOpts{
			Namespace: "CentralAccessGateway",
			Subsystem: "GateWayMetrics",
			Name:      "request_duration_seconds",
			Help:      "Request duration in seconds",
		}, []string{"method", "success"})
	}
	var endPoints []*serviceEndpoint.Set
	globalMetricsHolder := types.NewGlobalMetricsHolder()
	var (
		httpListener, err = net.Listen("tcp", httpAddr)
		server            = system.NewServer()
		basicServices     = service.New(logger, server, globalMetricsHolder)
	)
	for _, basicService := range basicServices {
		endPoints = append(endPoints, serviceEndpoint.New(basicService, logger, duration))
	}
	httpHandler := serviceTransport.NewHTTPHandler(endPoints, server, logger)

	if err != nil {
		logger.Log("transport", "HTTP", "during", "Listen", "err", err)
		os.Exit(1)
	}
	logger.Log("transport", "HTTP", "addr", httpAddr)
	err = http.Serve(httpListener, httpHandler)
	if err != nil {
		panic(err)
	}
}

